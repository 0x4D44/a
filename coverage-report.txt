    1|       |use base64::Engine;
    2|       |use std::collections::HashMap;
    3|       |use std::env;
    4|       |use std::fs;
    5|       |use std::io::{self, Write};
    6|       |use std::path::PathBuf;
    7|       |use std::process::{Command, Stdio};
    8|       |use std::sync::Arc;
    9|       |use std::time::Duration;
   10|       |
   11|       |const VERSION: &str = "1.3.0";
   12|       |// Hardcoded GitHub target for config sync
   13|       |const GITHUB_REPO: &str = "0x4d44/a"; // owner/repo
   14|       |const GITHUB_BRANCH: &str = "main";
   15|       |const GITHUB_CONFIG_PATH: &str = "config.json";
   16|       |
   17|       |// ANSI color codes
   18|       |const COLOR_RESET: &str = "\x1b[0m";
   19|       |const COLOR_BOLD: &str = "\x1b[1m";
   20|       |const COLOR_GREEN: &str = "\x1b[32m";
   21|       |const COLOR_BLUE: &str = "\x1b[34m";
   22|       |const COLOR_CYAN: &str = "\x1b[36m";
   23|       |const COLOR_YELLOW: &str = "\x1b[33m";
   24|       |const COLOR_GRAY: &str = "\x1b[90m";
   25|       |
   26|       |#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   27|       |enum ChainOperator {
   28|       |    And,         // && - run if previous succeeded
   29|       |    Or,          // || - run if previous failed
   30|       |    Always,      // ; - always run regardless
   31|       |    IfCode(i32), // run if previous exit code equals N
   32|       |}
   33|       |
   34|       |#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   35|       |struct ChainCommand {
   36|       |    command: String,
   37|       |    operator: Option<ChainOperator>, // None for the first command
   38|       |}
   39|       |
   40|       |#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   41|       |struct CommandChain {
   42|       |    commands: Vec<ChainCommand>,
   43|       |    parallel: bool,
   44|       |}
   45|       |
   46|       |#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   47|       |enum CommandType {
   48|       |    Simple(String),      // Single command (backward compatibility)
   49|       |    Chain(CommandChain), // Complex command chain
   50|       |}
   51|       |
   52|       |#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   53|       |struct AliasEntry {
   54|       |    command_type: CommandType,
   55|       |    description: Option<String>,
   56|       |    created: String,
   57|       |}
   58|       |
   59|       |trait CommandRunner: Send + Sync {
   60|       |    fn run(&self, program: &str, args: &[String]) -> Result<i32, String>;
   61|       |}
   62|       |
   63|       |#[derive(Default)]
   64|       |struct SystemCommandRunner;
   65|       |
   66|       |impl CommandRunner for SystemCommandRunner {
   67|      4|    fn run(&self, program: &str, args: &[String]) -> Result<i32, String> {
   68|      4|        let mut cmd = Command::new(program);
   69|      4|        cmd.args(args);
   70|       |
   71|      4|        cmd.stdin(Stdio::inherit())
   72|      4|            .stdout(Stdio::inherit())
   73|      4|            .stderr(Stdio::inherit());
   74|       |
   75|      4|        let status = cmd
                          ^2
   76|      4|            .status()
   77|      4|            .map_err(|e| format!("Failed to execute command '{}': {}", program, e))?;
                                               ^2                                                ^2
   78|       |
   79|      2|        Ok(status.code().unwrap_or(1))
   80|      4|    }
   81|       |}
   82|       |
   83|       |#[derive(Clone, Debug)]
   84|       |struct GitHubResponse {
   85|       |    status: u16,
   86|       |    body: Option<String>,
   87|       |    json: Option<serde_json::Value>,
   88|       |}
   89|       |
   90|       |impl GitHubResponse {
   91|       |    #[cfg(test)]
   92|      5|    fn from_status(status: u16) -> Self {
   93|      5|        Self {
   94|      5|            status,
   95|      5|            body: None,
   96|      5|            json: None,
   97|      5|        }
   98|      5|    }
   99|       |
  100|      3|    fn from_text(status: u16, text: String) -> Self {
  101|      3|        let json = serde_json::from_str(&text).ok();
  102|      3|        Self {
  103|      3|            status,
  104|      3|            body: Some(text),
  105|      3|            json,
  106|      3|        }
  107|      3|    }
  108|       |
  109|       |    #[cfg(test)]
  110|      3|    fn from_json(status: u16, json: serde_json::Value) -> Self {
  111|      3|        Self {
  112|      3|            status,
  113|      3|            body: None,
  114|      3|            json: Some(json),
  115|      3|        }
  116|      3|    }
  117|       |
  118|     14|    fn status(&self) -> u16 {
  119|     14|        self.status
  120|     14|    }
  121|       |
  122|      4|    fn json(&self) -> Option<&serde_json::Value> {
  123|      4|        self.json.as_ref()
  124|      4|    }
  125|       |
  126|      1|    fn body(&self) -> Option<&str> {
  127|      1|        self.body.as_deref()
  128|      1|    }
  129|       |}
  130|       |
  131|       |trait GitHubClient: Send + Sync {
  132|       |    fn get(&self, url: &str, headers: &[(&str, String)]) -> Result<GitHubResponse, String>;
  133|       |    fn put(
  134|       |        &self,
  135|       |        url: &str,
  136|       |        headers: &[(&str, String)],
  137|       |        body: serde_json::Value,
  138|       |    ) -> Result<GitHubResponse, String>;
  139|       |}
  140|       |
  141|       |#[derive(Clone)]
  142|       |struct UreqGitHubClient {
  143|       |    agent: ureq::Agent,
  144|       |}
  145|       |
  146|       |impl Default for UreqGitHubClient {
  147|     11|    fn default() -> Self {
  148|     11|        let agent = ureq::AgentBuilder::new()
  149|     11|            .timeout(Duration::from_secs(20))
  150|     11|            .build();
  151|     11|        Self { agent }
  152|     11|    }
  153|       |}
  154|       |
  155|       |impl UreqGitHubClient {
  156|       |    #[cfg(test)]
  157|      3|    fn with_agent(agent: ureq::Agent) -> Self {
  158|      3|        Self { agent }
  159|      3|    }
  160|       |}
  161|       |
  162|       |impl GitHubClient for UreqGitHubClient {
  163|      2|    fn get(&self, url: &str, headers: &[(&str, String)]) -> Result<GitHubResponse, String> {
  164|      2|        let mut request = self.agent.get(url);
  165|      4|        for (key, value) in headers {
                           ^2   ^2
  166|      2|            request = request.set(key, value);
  167|      2|        }
  168|       |
  169|      2|        match request.call() {
  170|      1|            Ok(resp) => {
  171|      1|                let status = resp.status();
  172|      1|                let text = resp.into_string().unwrap_or_default();
  173|      1|                Ok(GitHubResponse::from_text(status, text))
  174|       |            }
  175|      1|            Err(ureq::Error::Status(status, resp)) => {
  176|      1|                let text = resp.into_string().unwrap_or_default();
  177|      1|                Ok(GitHubResponse::from_text(status as u16, text))
  178|       |            }
  179|      0|            Err(e) => Err(format!("Failed to perform GitHub GET: {}", e)),
  180|       |        }
  181|      2|    }
  182|       |
  183|      1|    fn put(
  184|      1|        &self,
  185|      1|        url: &str,
  186|      1|        headers: &[(&str, String)],
  187|      1|        body: serde_json::Value,
  188|      1|    ) -> Result<GitHubResponse, String> {
  189|      1|        let mut request = self.agent.put(url);
  190|      2|        for (key, value) in headers {
                           ^1   ^1
  191|      1|            request = request.set(key, value);
  192|      1|        }
  193|       |
  194|      1|        match request.send_json(body) {
  195|      1|            Ok(resp) => {
  196|      1|                let status = resp.status();
  197|      1|                let text = resp.into_string().unwrap_or_default();
  198|      1|                Ok(GitHubResponse::from_text(status, text))
  199|       |            }
  200|      0|            Err(ureq::Error::Status(status, resp)) => {
  201|      0|                let text = resp.into_string().unwrap_or_default();
  202|      0|                Ok(GitHubResponse::from_text(status as u16, text))
  203|       |            }
  204|      0|            Err(e) => Err(format!("Failed to perform GitHub PUT: {}", e)),
  205|       |        }
  206|      1|    }
  207|       |}
  208|       |
  209|       |impl AliasEntry {
  210|       |    // Helper method to get command string for display (backward compatibility)
  211|      9|    fn command_display(&self) -> String {
  212|      9|        match &self.command_type {
  213|      7|            CommandType::Simple(cmd) => cmd.clone(),
  214|      2|            CommandType::Chain(chain) => {
  215|      2|                let mut result = String::new();
  216|      5|                for (i, chain_cmd) in chain.commands.iter().enumerate() {
                                                    ^2                    ^2
  217|      5|                    if i > 0 {
  218|      3|                        let op_str = match &chain_cmd.operator {
  219|      2|                            Some(ChainOperator::And) => " && ",
  220|      1|                            Some(ChainOperator::Or) => " || ",
  221|      0|                            Some(ChainOperator::Always) => " ; ",
  222|      0|                            Some(ChainOperator::IfCode(code)) => &format!(" ?[{}] ", code),
  223|      0|                            None => " ",
  224|       |                        };
  225|      3|                        result.push_str(op_str);
  226|      2|                    }
  227|      5|                    result.push_str(&chain_cmd.command);
  228|       |                }
  229|      2|                if chain.parallel {
  230|      0|                    format!("PARALLEL: {}", result)
  231|       |                } else {
  232|      2|                    result
  233|       |                }
  234|       |            }
  235|       |        }
  236|      9|    }
  237|       |}
  238|       |
  239|       |#[derive(Debug, serde::Serialize, serde::Deserialize)]
  240|       |struct Config {
  241|       |    aliases: HashMap<String, AliasEntry>,
  242|       |}
  243|       |
  244|       |impl Config {
  245|     34|    fn new() -> Self {
  246|     34|        Config {
  247|     34|            aliases: HashMap::new(),
  248|     34|        }
  249|     34|    }
  250|       |
  251|     20|    fn add_alias(
  252|     20|        &mut self,
  253|     20|        name: String,
  254|     20|        command_type: CommandType,
  255|     20|        description: Option<String>,
  256|     20|        force: bool,
  257|     20|    ) -> Result<bool, String> {
  258|     20|        if name.starts_with("--") || name.contains("mgr:") || name.starts_with(".") {
                                                   ^19                      ^18
  259|      3|            return Err(format!(
  260|      3|                "Invalid alias name '{}': cannot use reserved prefixes",
  261|      3|                name
  262|      3|            ));
  263|     17|        }
  264|       |
  265|     17|        let is_overwrite = self.aliases.contains_key(&name);
  266|     17|        if is_overwrite && !force {
                                         ^0
  267|      0|            return Ok(false); // Signal that confirmation is needed
  268|     17|        }
  269|       |
  270|     17|        let entry = AliasEntry {
  271|     17|            command_type,
  272|     17|            description,
  273|     17|            created: chrono::Utc::now().format("%Y-%m-%d").to_string(),
  274|     17|        };
  275|       |
  276|     17|        self.aliases.insert(name, entry);
  277|     17|        Ok(true) // Successfully added/updated
  278|     20|    }
  279|       |
  280|      4|    fn remove_alias(&mut self, name: &str) -> Result<(), String> {
  281|      4|        if self.aliases.remove(name).is_some() {
  282|      2|            Ok(())
  283|       |        } else {
  284|      2|            Err(format!("Alias '{}' not found", name))
  285|       |        }
  286|      4|    }
  287|       |
  288|     13|    fn get_alias(&self, name: &str) -> Option<&AliasEntry> {
  289|     13|        self.aliases.get(name)
  290|     13|    }
  291|       |
  292|      5|    fn list_aliases(&self, filter: Option<&str>) -> Vec<(&String, &AliasEntry)> {
  293|      5|        let mut aliases: Vec<_> = self.aliases.iter().collect();
  294|       |
  295|      5|        if let Some(pattern) = filter {
                                  ^3
  296|      7|            aliases.retain(|(name, _)| name.contains(pattern));
                          ^3      ^3
  297|      2|        }
  298|       |
  299|      5|        aliases.sort_by_key(|(name, _)| *name);
  300|      5|        aliases
  301|      5|    }
  302|       |}
  303|       |
  304|       |struct AliasManager {
  305|       |    config: Config,
  306|       |    config_path: PathBuf,
  307|       |    command_runner: Arc<dyn CommandRunner + Send + Sync>,
  308|       |    github_client: Arc<dyn GitHubClient + Send + Sync>,
  309|       |}
  310|       |
  311|       |impl AliasManager {
  312|     12|    fn new() -> Result<Self, String> {
  313|     12|        let config_path = Self::get_config_path()?;
                          ^11                                  ^1
  314|     11|        let config = Self::load_config(&config_path)?;
                                                                  ^0
  315|       |
  316|     11|        let runner: Arc<dyn CommandRunner + Send + Sync> = Arc::new(SystemCommandRunner::default());
  317|     11|        let github: Arc<dyn GitHubClient + Send + Sync> = Arc::new(UreqGitHubClient::default());
  318|       |
  319|     11|        Ok(Self::with_dependencies(config, config_path, runner, github))
  320|     12|    }
  321|       |
  322|     29|    fn with_dependencies(
  323|     29|        config: Config,
  324|     29|        config_path: PathBuf,
  325|     29|        command_runner: Arc<dyn CommandRunner + Send + Sync>,
  326|     29|        github_client: Arc<dyn GitHubClient + Send + Sync>,
  327|     29|    ) -> Self {
  328|     29|        AliasManager {
  329|     29|            config,
  330|     29|            config_path,
  331|     29|            command_runner,
  332|     29|            github_client,
  333|     29|        }
  334|     29|    }
  335|       |
  336|     13|    fn get_config_path() -> Result<PathBuf, String> {
  337|     13|        let home_dir = if cfg!(windows) {
                          ^12
  338|      0|            env::var("USERPROFILE").map_err(|_| "USERPROFILE environment variable not found")?
  339|       |        } else {
  340|     13|            env::var("HOME").map_err(|_| "HOME environment variable not found")?
                                                                                             ^1
  341|       |        };
  342|       |
  343|     12|        let mut config_dir = PathBuf::from(home_dir);
  344|     12|        config_dir.push(".alias-mgr");
  345|       |
  346|     12|        if !config_dir.exists() {
  347|      1|            fs::create_dir_all(&config_dir)
  348|      1|                .map_err(|e| format!("Failed to create config directory: {}", e))?;
                                                   ^0                                          ^0
  349|     11|        }
  350|       |
  351|     12|        config_dir.push("config.json");
  352|     12|        Ok(config_dir)
  353|     13|    }
  354|       |
  355|     13|    fn load_config(path: &PathBuf) -> Result<Config, String> {
  356|     13|        if !path.exists() {
  357|      6|            return Ok(Config::new());
  358|      7|        }
  359|       |
  360|      7|        let content =
  361|      7|            fs::read_to_string(path).map_err(|e| format!("Failed to read config file: {}", e))?;
                                                                       ^0                                   ^0
  362|       |
  363|       |        // Try to parse as new format first
  364|      7|        match serde_json::from_str::<Config>(&content) {
  365|      6|            Ok(config) => Ok(config),
  366|       |            Err(_) => {
  367|       |                // Try to parse as legacy format and migrate
  368|      1|                Self::migrate_legacy_config(&content)
  369|       |            }
  370|       |        }
  371|     13|    }
  372|       |
  373|      2|    fn migrate_legacy_config(content: &str) -> Result<Config, String> {
  374|       |        // Legacy format has "command" field instead of "command_type"
  375|       |        #[derive(serde::Deserialize)]
  376|       |        struct LegacyAliasEntry {
  377|       |            command: String,
  378|       |            description: Option<String>,
  379|       |            created: String,
  380|       |        }
  381|       |
  382|       |        #[derive(serde::Deserialize)]
  383|       |        struct LegacyConfig {
  384|       |            aliases: HashMap<String, LegacyAliasEntry>,
  385|       |        }
  386|       |
  387|      2|        let legacy_config: LegacyConfig = serde_json::from_str(content)
  388|      2|            .map_err(|e| format!("Failed to parse legacy config file: {}", e))?;
                                               ^0                                           ^0
  389|       |
  390|       |        // Convert to new format
  391|      2|        let mut new_config = Config::new();
  392|      4|        for (name, legacy_entry) in legacy_config.aliases {
                           ^2    ^2
  393|      2|            let command_type = if legacy_entry.command.contains(" && ") {
  394|       |                // Convert legacy chained commands to simple format for now
  395|      0|                CommandType::Simple(legacy_entry.command)
  396|       |            } else {
  397|      2|                CommandType::Simple(legacy_entry.command)
  398|       |            };
  399|       |
  400|      2|            let new_entry = AliasEntry {
  401|      2|                command_type,
  402|      2|                description: legacy_entry.description,
  403|      2|                created: legacy_entry.created,
  404|      2|            };
  405|       |
  406|      2|            new_config.aliases.insert(name, new_entry);
  407|       |        }
  408|       |
  409|      2|        Ok(new_config)
  410|      2|    }
  411|       |
  412|      9|    fn save_config(&self) -> Result<(), String> {
  413|      9|        let content = serde_json::to_string_pretty(&self.config)
  414|      9|            .map_err(|e| format!("Failed to serialize config: {}", e))?;
                                               ^0                                   ^0
  415|       |
  416|      9|        fs::write(&self.config_path, content)
  417|      9|            .map_err(|e| format!("Failed to save config file: {}", e))
                                               ^0
  418|      9|    }
  419|       |
  420|      8|    fn github_token() -> Option<String> {
  421|      8|        env::var("A_GITHUB_TOKEN")
  422|      8|            .ok()
  423|      8|            .or_else(|| env::var("GITHUB_TOKEN").ok())
                                      ^4                       ^4
  424|      8|            .or_else(|| env::var("GH_TOKEN").ok())
                                      ^3                   ^3
  425|      8|    }
  426|       |
  427|      5|    fn push_config_to_github(&self, message: Option<&str>) -> Result<(), String> {
  428|      5|        let repo = GITHUB_REPO;
  429|      5|        let branch = GITHUB_BRANCH;
  430|      5|        let path_in_repo = GITHUB_CONFIG_PATH;
  431|      5|        let commit_message = message.unwrap_or("chore(config): update alias config");
  432|       |
  433|      5|        let token = Self::github_token().ok_or_else(|| {
                          ^3                                         ^2
  434|      2|            "Missing GitHub token. Set A_GITHUB_TOKEN or GITHUB_TOKEN.".to_string()
  435|      2|        })?;
  436|       |
  437|      3|        if !self.config_path.exists() {
  438|      0|            return Err(
  439|      0|                "Source config file does not exist. Create some aliases first.".to_string(),
  440|      0|            );
  441|      3|        }
  442|       |
  443|      3|        let content_bytes = fs::read(&self.config_path)
  444|      3|            .map_err(|e| format!("Failed to read config file: {}", e))?;
                                               ^0                                   ^0
  445|      3|        let content_b64 = base64::engine::general_purpose::STANDARD.encode(content_bytes);
  446|       |
  447|      3|        let api_base = format!(
  448|      3|            "https://api.github.com/repos/{}/contents/{}",
  449|       |            repo, path_in_repo
  450|       |        );
  451|      3|        let get_url = format!("{}?ref={}", api_base, branch);
  452|       |
  453|      3|        let headers = vec![
  454|      3|            ("User-Agent", "a-alias-manager".to_string()),
  455|      3|            ("Authorization", format!("Bearer {}", token)),
  456|       |        ];
  457|       |
  458|      3|        let mut maybe_sha: Option<String> = None;
  459|      3|        let get_response = self.github_client.get(&get_url, &headers)?;
                                                                                   ^0
  460|      3|        match get_response.status() {
  461|       |            200 => {
  462|      1|                if let Some(json) = get_response.json() {
  463|      1|                    if let Some(sha) = json.get("sha").and_then(|v| v.as_str()) {
  464|      1|                        maybe_sha = Some(sha.to_string());
  465|      1|                    }
                                  ^0
  466|      0|                }
  467|       |            }
  468|      2|            404 => {}
  469|      0|            status => {
  470|      0|                return Err(format!("Failed to query existing file: status {}", status));
  471|       |            }
  472|       |        }
  473|       |
  474|      3|        let mut body = serde_json::json!({
  475|      3|            "message": commit_message,
  476|      3|            "content": content_b64,
  477|      3|            "branch": branch,
  478|       |        });
  479|      3|        if let Some(sha) = maybe_sha {
                                  ^1
  480|      1|            body["sha"] = serde_json::Value::String(sha);
  481|      2|        }
  482|       |
  483|      3|        let put_response = self.github_client.put(&api_base, &headers, body)?;
                                                                                          ^0
  484|       |
  485|      3|        if put_response.status() == 200 || put_response.status() == 201 {
                                                         ^2
  486|      2|            println!(
  487|      2|                "{}Config pushed to GitHub:{} https://github.com/{}/blob/{}/{}",
  488|       |                COLOR_GREEN, COLOR_RESET, repo, branch, path_in_repo
  489|       |            );
  490|      2|            Ok(())
  491|       |        } else {
  492|      1|            Err(format!(
  493|      1|                "GitHub API returned status {}",
  494|      1|                put_response.status()
  495|      1|            ))
  496|       |        }
  497|      5|    }
  498|       |
  499|      2|    fn pull_config_from_github(&mut self) -> Result<(), String> {
  500|      2|        let repo = GITHUB_REPO;
  501|      2|        let branch = GITHUB_BRANCH;
  502|      2|        let path_in_repo = GITHUB_CONFIG_PATH;
  503|       |
  504|      2|        let token_opt = Self::github_token();
  505|       |
  506|      2|        let api_url = format!(
  507|      2|            "https://api.github.com/repos/{}/contents/{}?ref={}",
  508|       |            repo, path_in_repo, branch
  509|       |        );
  510|      2|        let mut headers = vec![("User-Agent", "a-alias-manager".to_string())];
  511|      2|        if let Some(token) = &token_opt {
                                  ^1
  512|      1|            headers.push(("Authorization", format!("Bearer {}", token)));
  513|      1|        }
  514|       |
  515|      2|        let response = self.github_client.get(&api_url, &headers)?;
                                                                               ^0
  516|      2|        if response.status() != 200 {
  517|      0|            return Err(format!("GitHub API returned status {}", response.status()));
  518|      2|        }
  519|       |
  520|      2|        let val = response
  521|      2|            .json()
  522|      2|            .cloned()
  523|      2|            .or_else(|| {
                                      ^0
  524|      0|                response
  525|      0|                    .body()
  526|      0|                    .and_then(|text| serde_json::from_str::<serde_json::Value>(text).ok())
  527|      0|            })
  528|      2|            .ok_or_else(|| "Failed to parse GitHub response".to_string())?;
                                         ^0                                ^0          ^0
  529|       |
  530|      2|        let encoding = val
  531|      2|            .get("encoding")
  532|      2|            .and_then(|v| v.as_str())
  533|      2|            .ok_or_else(|| "Missing encoding in GitHub response".to_string())?;
                                         ^0                                    ^0          ^0
  534|      2|        if encoding != "base64" {
  535|      1|            return Err("Unsupported encoding from GitHub".to_string());
  536|      1|        }
  537|      1|        let content_b64 = val
  538|      1|            .get("content")
  539|      1|            .and_then(|v| v.as_str())
  540|      1|            .ok_or_else(|| "Missing content in GitHub response".to_string())?;
                                         ^0                                   ^0          ^0
  541|       |
  542|      1|        let content_clean = content_b64.replace('\n', "");
  543|      1|        let bytes = base64::engine::general_purpose::STANDARD
  544|      1|            .decode(content_clean)
  545|      1|            .map_err(|e| format!("Failed to decode content: {}", e))?;
                                               ^0                                 ^0
  546|      1|        let text = String::from_utf8(bytes).map_err(|e| format!("Invalid UTF-8 content: {}", e))?;
                                                                              ^0                              ^0
  547|       |
  548|      1|        let parsed: Config = serde_json::from_str(&text)
  549|      1|            .map_err(|e| format!("Downloaded config is invalid JSON: {}", e))?;
                                               ^0                                          ^0
  550|       |
  551|      1|        if self.config_path.exists() {
  552|      1|            let mut backup_path = self.config_path.clone();
  553|      1|            backup_path.set_file_name("config.backup.json");
  554|      1|            fs::copy(&self.config_path, &backup_path)
  555|      1|                .map_err(|e| format!("Failed to create backup: {}", e))?;
                                                   ^0                                ^0
  556|      1|            println!(
  557|      1|                "{}Existing config backed up to:{} {}",
  558|       |                COLOR_GRAY,
  559|       |                COLOR_RESET,
  560|      1|                backup_path.display()
  561|       |            );
  562|      0|        }
  563|       |
  564|      1|        fs::write(&self.config_path, text)
  565|      1|            .map_err(|e| format!("Failed to write config file: {}", e))?;
                                               ^0                                    ^0
  566|      1|        self.config = parsed;
  567|       |
  568|      1|        println!(
  569|      1|            "{}Config pulled from GitHub:{} https://github.com/{}/blob/{}/{}",
  570|       |            COLOR_GREEN, COLOR_RESET, repo, branch, path_in_repo
  571|       |        );
  572|      1|        println!(
  573|      1|            "{}File contains {} aliases{}",
  574|       |            COLOR_GRAY,
  575|      1|            self.config.aliases.len(),
  576|       |            COLOR_RESET
  577|       |        );
  578|       |
  579|      1|        Ok(())
  580|      2|    }
  581|       |
  582|      8|    fn add_alias(
  583|      8|        &mut self,
  584|      8|        name: String,
  585|      8|        command_type: CommandType,
  586|      8|        description: Option<String>,
  587|      8|        force: bool,
  588|      8|    ) -> Result<(), String> {
  589|       |        // Check if alias already exists before making changes
  590|      8|        let alias_existed = self.config.aliases.contains_key(&name);
  591|       |
  592|       |        // Check if alias exists and get confirmation if needed
  593|      8|        let confirmed_force = if alias_existed && !force {
                                                                ^0
  594|      0|            let existing = self.config.get_alias(&name).unwrap();
  595|      0|            println!(
  596|      0|                "{}Alias '{}' already exists:{}",
  597|       |                COLOR_YELLOW, name, COLOR_RESET
  598|       |            );
  599|      0|            println!(
  600|      0|                "  {}Current:{} {}",
  601|       |                COLOR_CYAN,
  602|       |                COLOR_RESET,
  603|      0|                existing.command_display()
  604|       |            );
  605|      0|            if let Some(desc) = &existing.description {
  606|      0|                println!("  {}Description:{} {}", COLOR_CYAN, COLOR_RESET, desc);
  607|      0|            }
  608|      0|            println!(
  609|      0|                "  {}New:{} {}",
  610|       |                COLOR_CYAN,
  611|       |                COLOR_RESET,
  612|      0|                match &command_type {
  613|      0|                    CommandType::Simple(cmd) => cmd.clone(),
  614|      0|                    CommandType::Chain(chain) =>
  615|      0|                        format!("Complex chain with {} commands", chain.commands.len()),
  616|       |                }
  617|       |            );
  618|       |
  619|      0|            if !Self::confirm_overwrite()? {
  620|      0|                println!("{}Alias not modified.{}", COLOR_GRAY, COLOR_RESET);
  621|      0|                return Ok(());
  622|      0|            }
  623|      0|            true // User confirmed, so force the update
  624|       |        } else {
  625|      8|            force // Use the original force value
  626|       |        };
  627|       |
  628|      8|        match self
  629|      8|            .config
  630|      8|            .add_alias(name.clone(), command_type, description, confirmed_force)
  631|       |        {
  632|       |            Ok(true) => {
  633|      8|                self.save_config()?;
                                                ^0
  634|      8|                if alias_existed {
  635|      0|                    println!("{}Updated alias '{}'{}", COLOR_GREEN, name, COLOR_RESET);
  636|      8|                } else {
  637|      8|                    println!("{}Added alias '{}'{}", COLOR_GREEN, name, COLOR_RESET);
  638|      8|                }
  639|      8|                Ok(())
  640|       |            }
  641|       |            Ok(false) => {
  642|       |                // This shouldn't happen with the current logic, but handle it gracefully
  643|      0|                Err("Unexpected confirmation state".to_string())
  644|       |            }
  645|      0|            Err(e) => Err(e),
  646|       |        }
  647|      8|    }
  648|       |
  649|      0|    fn confirm_overwrite() -> Result<bool, String> {
  650|      0|        let stdin = io::stdin();
  651|      0|        let mut stdout = io::stdout();
  652|      0|        let mut reader = stdin.lock();
  653|      0|        Self::confirm_overwrite_with_reader(&mut reader, &mut stdout)
  654|      0|    }
  655|       |
  656|      3|    fn confirm_overwrite_with_reader<R, W>(reader: &mut R, writer: &mut W) -> Result<bool, String>
  657|      3|    where
  658|      3|        R: io::BufRead,
  659|      3|        W: Write,
  660|       |    {
  661|      3|        write!(writer, "{}Overwrite? (y/N):{} ", COLOR_YELLOW, COLOR_RESET)
  662|      3|            .map_err(|e| format!("Failed to write prompt: {}", e))?;
                                               ^1                               ^1
  663|      2|        writer
  664|      2|            .flush()
  665|      2|            .map_err(|e| format!("Failed to flush stdout: {}", e))?;
                                               ^0                               ^0
  666|       |
  667|      2|        let mut input = String::new();
  668|      2|        reader
  669|      2|            .read_line(&mut input)
  670|      2|            .map_err(|e| format!("Failed to read input: {}", e))?;
                                               ^0                             ^0
  671|       |
  672|      2|        let response = input.trim().to_lowercase();
  673|      2|        Ok(response == "y" || response == "yes")
                                            ^1
  674|      3|    }
  675|       |
  676|      2|    fn remove_alias(&mut self, name: &str) -> Result<(), String> {
  677|      2|        self.config.remove_alias(name)?;
                                                    ^1
  678|      1|        self.save_config()
  679|      2|    }
  680|       |
  681|      2|    fn list_aliases(&self, filter: Option<&str>) {
  682|      2|        let aliases = self.config.list_aliases(filter);
  683|       |
  684|      2|        if aliases.is_empty() {
  685|      1|            if filter.is_some() {
  686|      1|                println!(
  687|      1|                    "{}No aliases found matching filter.{}",
  688|      1|                    COLOR_YELLOW, COLOR_RESET
  689|      1|                );
  690|      1|            } else {
  691|      0|                println!("{}No aliases configured.{}", COLOR_YELLOW, COLOR_RESET);
  692|      0|            }
  693|      1|            return;
  694|      1|        }
  695|       |
  696|      1|        println!(
  697|      1|            "{}{}Configured aliases:{}",
  698|       |            COLOR_BOLD, COLOR_CYAN, COLOR_RESET
  699|       |        );
  700|       |
  701|       |        // Calculate the maximum alias name length for alignment
  702|      1|        let max_name_len = aliases
  703|      1|            .iter()
  704|      2|            .map(|(name, _)| name.len())
                           ^1
  705|      1|            .max()
  706|      1|            .unwrap_or(0);
  707|      1|        let name_width = std::cmp::max(16, ((max_name_len + 4) / 4) * 4); // Minimum 16 chars, rounded to 4
  708|       |
  709|      3|        for (name, entry) in aliases {
                           ^2    ^2
  710|      2|            let padding = name_width.saturating_sub(name.len());
  711|      2|            let spaces = " ".repeat(padding);
  712|       |
  713|      2|            print!(
  714|      2|                "  {}{}{}{} -> {}{}{}",
  715|       |                COLOR_GREEN,
  716|       |                name,
  717|       |                COLOR_RESET,
  718|       |                spaces,
  719|       |                COLOR_BLUE,
  720|      2|                entry.command_display(),
  721|       |                COLOR_RESET
  722|       |            );
  723|       |
  724|      2|            if let Some(desc) = &entry.description {
                                      ^1
  725|      1|                print!(" {}({}){}", COLOR_GRAY, desc, COLOR_RESET);
  726|      1|            }
  727|       |
  728|      2|            println!(" {}[{}]{}", COLOR_GRAY, entry.created, COLOR_RESET);
  729|       |        }
  730|      2|    }
  731|       |
  732|      1|    fn which_alias(&self, name: &str) {
  733|      1|        if let Some(entry) = self.config.get_alias(name) {
  734|      1|            println!(
  735|      1|                "{}Alias '{}' executes:{} {}",
  736|       |                COLOR_CYAN,
  737|       |                name,
  738|       |                COLOR_RESET,
  739|      1|                entry.command_display()
  740|       |            );
  741|      1|            if let Some(desc) = &entry.description {
  742|      1|                println!("{}Description:{} {}", COLOR_CYAN, COLOR_RESET, desc);
  743|      1|            }
                          ^0
  744|       |
  745|       |            // Check if any commands contain parameter variables
  746|      1|            let has_variables = match &entry.command_type {
  747|      1|                CommandType::Simple(cmd) => Self::has_parameter_variables(cmd),
  748|      0|                CommandType::Chain(chain) => chain
  749|      0|                    .commands
  750|      0|                    .iter()
  751|      0|                    .any(|cmd| Self::has_parameter_variables(&cmd.command)),
  752|       |            };
  753|       |
  754|       |            // Show parameter substitution examples if variables are present
  755|      1|            if has_variables {
  756|      0|                println!(
  757|      0|                    "{}Parameter substitution example:{}",
  758|       |                    COLOR_CYAN, COLOR_RESET
  759|       |                );
  760|      0|                let example_args = vec!["arg1".to_string(), "arg2".to_string(), "arg3".to_string()];
  761|       |
  762|      0|                match &entry.command_type {
  763|      0|                    CommandType::Simple(cmd) => {
  764|      0|                        let resolved = Self::substitute_parameters(cmd, &example_args);
  765|      0|                        println!(
  766|      0|                            "  {}a{} {} {}arg1 arg2 arg3{}",
  767|      0|                            COLOR_GREEN, COLOR_RESET, name, COLOR_YELLOW, COLOR_RESET
  768|      0|                        );
  769|      0|                        println!("  {}Resolves to:{} {}", COLOR_GRAY, COLOR_RESET, resolved);
  770|      0|                    }
  771|      0|                    CommandType::Chain(chain) => {
  772|      0|                        println!(
  773|      0|                            "  {}a{} {} {}arg1 arg2 arg3{}",
  774|       |                            COLOR_GREEN, COLOR_RESET, name, COLOR_YELLOW, COLOR_RESET
  775|       |                        );
  776|      0|                        println!("  {}Resolves to:{}", COLOR_GRAY, COLOR_RESET);
  777|      0|                        for (i, chain_cmd) in chain.commands.iter().enumerate() {
  778|      0|                            let resolved =
  779|      0|                                Self::substitute_parameters(&chain_cmd.command, &example_args);
  780|      0|                            let op_prefix = if i > 0 { " && " } else { "" };
  781|      0|                            println!("    {}{}{}", COLOR_BLUE, op_prefix, resolved);
  782|       |                        }
  783|       |                    }
  784|       |                }
  785|      0|                println!();
  786|      1|            }
  787|       |
  788|       |            // Show detailed breakdown for complex chains
  789|      1|            if let CommandType::Chain(chain) = &entry.command_type {
                                                    ^0
  790|      0|                println!("{}Command breakdown:{}", COLOR_CYAN, COLOR_RESET);
  791|      0|                for (i, chain_cmd) in chain.commands.iter().enumerate() {
  792|      0|                    let op_desc = match &chain_cmd.operator {
  793|      0|                        Some(ChainOperator::And) => " (run if previous succeeded)",
  794|      0|                        Some(ChainOperator::Or) => " (run if previous failed)",
  795|      0|                        Some(ChainOperator::Always) => " (always run)",
  796|      0|                        Some(ChainOperator::IfCode(code)) => {
  797|      0|                            &format!(" (run if previous exit code = {})", code)
  798|       |                        }
  799|      0|                        None => "",
  800|       |                    };
  801|      0|                    let has_vars = if Self::has_parameter_variables(&chain_cmd.command) {
  802|      0|                        " ðŸ“‹"
  803|       |                    } else {
  804|      0|                        ""
  805|       |                    };
  806|      0|                    println!(
  807|      0|                        "  {}{}. {}{}{}{}{}",
  808|       |                        COLOR_GRAY,
  809|      0|                        i + 1,
  810|       |                        COLOR_RESET,
  811|       |                        chain_cmd.command,
  812|       |                        has_vars,
  813|       |                        COLOR_GRAY,
  814|       |                        op_desc
  815|       |                    );
  816|       |                }
  817|      0|                if chain.parallel {
  818|      0|                    println!("{}Execution mode:{} Parallel", COLOR_CYAN, COLOR_RESET);
  819|      0|                } else {
  820|      0|                    println!("{}Execution mode:{} Sequential", COLOR_CYAN, COLOR_RESET);
  821|      0|                }
  822|      1|            }
  823|      0|        } else {
  824|      0|            println!("{}Alias '{}' not found.{}", COLOR_YELLOW, name, COLOR_RESET);
  825|      0|        }
  826|      1|    }
  827|       |
  828|      1|    fn show_config_location(&self) {
  829|      1|        println!(
  830|      1|            "{}Config file location:{} {}",
  831|       |            COLOR_CYAN,
  832|       |            COLOR_RESET,
  833|      1|            self.config_path.display()
  834|       |        );
  835|      1|    }
  836|       |
  837|      6|    fn export_config(&self, target_path: Option<&str>) -> Result<(), String> {
  838|       |        // Determine target directory - current directory if not specified
  839|      6|        let target_dir = if let Some(path) = target_path {
                                                   ^4
  840|      4|            PathBuf::from(path)
  841|       |        } else {
  842|      2|            env::current_dir().map_err(|e| format!("Failed to get current directory: {}", e))?
                                                                 ^0                                        ^0
  843|       |        };
  844|       |
  845|       |        // Ensure target is a directory (or create it if it doesn't exist)
  846|      6|        if target_dir.exists() && !target_dir.is_dir() {
                                                ^3
  847|      1|            return Err(format!(
  848|      1|                "Target path '{}' exists but is not a directory",
  849|      1|                target_dir.display()
  850|      1|            ));
  851|      5|        }
  852|       |
  853|      5|        if !target_dir.exists() {
  854|      3|            fs::create_dir_all(&target_dir).map_err(|e| {
                                                                      ^0
  855|      0|                format!(
  856|      0|                    "Failed to create target directory '{}': {}",
  857|      0|                    target_dir.display(),
  858|       |                    e
  859|       |                )
  860|      0|            })?;
  861|      2|        }
  862|       |
  863|       |        // Construct target file path
  864|      5|        let target_file = target_dir.join("config.json");
  865|       |
  866|       |        // Check if source config file exists
  867|      5|        if !self.config_path.exists() {
  868|      2|            return Err(
  869|      2|                "Source config file does not exist. Create some aliases first.".to_string(),
  870|      2|            );
  871|      3|        }
  872|       |
  873|       |        // Copy the config file
  874|      3|        fs::copy(&self.config_path, &target_file)
  875|      3|            .map_err(|e| format!("Failed to copy config file: {}", e))?;
                                               ^0                                   ^0
  876|       |
  877|      3|        println!(
  878|      3|            "{}Config exported to:{} {}",
  879|       |            COLOR_GREEN,
  880|       |            COLOR_RESET,
  881|      3|            target_file.display()
  882|       |        );
  883|      3|        println!(
  884|      3|            "{}File contains {} aliases{}",
  885|       |            COLOR_GRAY,
  886|      3|            self.config.aliases.len(),
  887|       |            COLOR_RESET
  888|       |        );
  889|       |
  890|      3|        Ok(())
  891|      6|    }
  892|       |
  893|      1|    fn execute_alias(&self, name: &str, args: &[String]) -> Result<(), String> {
  894|      1|        let entry = self
  895|      1|            .config
  896|      1|            .get_alias(name)
  897|      1|            .ok_or_else(|| format!("Alias '{}' not found", name))?;
                                                 ^0                            ^0
  898|       |
  899|      1|        match &entry.command_type {
  900|      1|            CommandType::Simple(command) => {
  901|       |                // Check if this is a legacy chained command (contains &&)
  902|      1|                if command.contains(" && ") {
  903|      0|                    self.execute_legacy_command_chain(command, args)
  904|       |                } else {
  905|      1|                    self.execute_single_command(command, args)
  906|       |                }
  907|       |            }
  908|      0|            CommandType::Chain(chain) => {
  909|      0|                if chain.parallel {
  910|      0|                    self.execute_parallel_chain(chain, args)
  911|       |                } else {
  912|      0|                    self.execute_sequential_chain(chain, args)
  913|       |                }
  914|       |            }
  915|       |        }
  916|      1|    }
  917|       |
  918|      0|    fn execute_legacy_command_chain(
  919|      0|        &self,
  920|      0|        full_command: &str,
  921|      0|        additional_args: &[String],
  922|      0|    ) -> Result<(), String> {
  923|      0|        let commands: Vec<&str> = full_command.split(" && ").collect();
  924|       |
  925|      0|        for (index, command_str) in commands.iter().enumerate() {
  926|      0|            let command_str = command_str.trim();
  927|      0|            if command_str.is_empty() {
  928|      0|                continue;
  929|      0|            }
  930|       |
  931|       |            // Only add additional args to the last command in the chain
  932|      0|            let args_to_use = if index == commands.len() - 1 {
  933|      0|                additional_args
  934|       |            } else {
  935|      0|                &[]
  936|       |            };
  937|       |
  938|      0|            println!(
  939|      0|                "{}[{}/{}]{} Executing: {}{}{}",
  940|       |                COLOR_GRAY,
  941|      0|                index + 1,
  942|      0|                commands.len(),
  943|       |                COLOR_RESET,
  944|       |                COLOR_CYAN,
  945|       |                command_str,
  946|       |                COLOR_RESET
  947|       |            );
  948|       |
  949|      0|            match self.execute_single_command(command_str, args_to_use) {
  950|      0|                Ok(()) => continue,
  951|      0|                Err(e) => {
  952|      0|                    eprintln!("{}Command failed:{} {}", COLOR_YELLOW, COLOR_RESET, e);
  953|      0|                    eprintln!(
  954|      0|                        "{}Stopping command chain at step {}/{}{}",
  955|       |                        COLOR_YELLOW,
  956|      0|                        index + 1,
  957|      0|                        commands.len(),
  958|       |                        COLOR_RESET
  959|       |                    );
  960|      0|                    return Err(format!("Command chain stopped at step {}", index + 1));
  961|       |                }
  962|       |            }
  963|       |        }
  964|       |
  965|      0|        println!(
  966|      0|            "{}Command chain completed successfully{}",
  967|       |            COLOR_GREEN, COLOR_RESET
  968|       |        );
  969|      0|        Ok(())
  970|      0|    }
  971|       |
  972|      1|    fn execute_sequential_chain(
  973|      1|        &self,
  974|      1|        chain: &CommandChain,
  975|      1|        additional_args: &[String],
  976|      1|    ) -> Result<(), String> {
  977|      1|        let mut last_exit_code = 0;
  978|       |
  979|      3|        for (index, chain_cmd) in chain.commands.iter().enumerate() {
                                                ^1                    ^1
  980|      3|            let should_execute = match &chain_cmd.operator {
                                                     ^2
  981|      1|                None => true, // First command always executes
  982|      1|                Some(ChainOperator::And) => last_exit_code == 0,
  983|      1|                Some(ChainOperator::Or) => last_exit_code != 0,
  984|      0|                Some(ChainOperator::Always) => true,
  985|      0|                Some(ChainOperator::IfCode(code)) => last_exit_code == *code,
  986|       |            };
  987|       |
  988|      3|            if !should_execute {
  989|      0|                let reason = match &chain_cmd.operator {
  990|       |                    Some(ChainOperator::And) => {
  991|      0|                        format!("previous command failed (exit code {})", last_exit_code)
  992|       |                    }
  993|      0|                    Some(ChainOperator::Or) => "previous command succeeded".to_string(),
  994|      0|                    Some(ChainOperator::IfCode(code)) => format!(
  995|      0|                        "previous exit code was {}, expected {}",
  996|       |                        last_exit_code, code
  997|       |                    ),
  998|      0|                    _ => "unknown condition".to_string(),
  999|       |                };
 1000|      0|                println!(
 1001|      0|                    "{}[{}/{}]{} Skipping: {}{}{} ({})",
 1002|       |                    COLOR_GRAY,
 1003|      0|                    index + 1,
 1004|      0|                    chain.commands.len(),
 1005|       |                    COLOR_RESET,
 1006|       |                    COLOR_GRAY,
 1007|       |                    chain_cmd.command,
 1008|       |                    COLOR_RESET,
 1009|       |                    reason
 1010|       |                );
 1011|      0|                continue;
 1012|      3|            }
 1013|       |
 1014|       |            // If any command in the chain has parameter variables, pass args to all commands
 1015|       |            // Otherwise, only pass args to the last command (backward compatibility)
 1016|      3|            let has_vars_in_chain = chain
 1017|      3|                .commands
 1018|      3|                .iter()
 1019|      9|                .any(|cmd| Self::has_parameter_variables(&cmd.command));
                               ^3
 1020|      3|            let args_to_use = if has_vars_in_chain || index == chain.commands.len() - 1 {
 1021|      1|                additional_args
 1022|       |            } else {
 1023|      2|                &[]
 1024|       |            };
 1025|       |
 1026|      3|            let op_desc = match &chain_cmd.operator {
                                              ^2
 1027|      1|                Some(ChainOperator::And) => " (&&)",
 1028|      1|                Some(ChainOperator::Or) => " (||)",
 1029|      0|                Some(ChainOperator::Always) => " (;)",
 1030|      0|                Some(ChainOperator::IfCode(code)) => &format!(" (?[{}])", code),
 1031|      1|                None => "",
 1032|       |            };
 1033|       |
 1034|      3|            println!(
 1035|      3|                "{}[{}/{}]{}{} Executing: {}{}{}",
 1036|       |                COLOR_GRAY,
 1037|      3|                index + 1,
 1038|      3|                chain.commands.len(),
 1039|       |                COLOR_RESET,
 1040|       |                op_desc,
 1041|       |                COLOR_CYAN,
 1042|       |                chain_cmd.command,
 1043|       |                COLOR_RESET
 1044|       |            );
 1045|       |
 1046|      3|            last_exit_code = self
 1047|      3|                .execute_single_command_with_exit_code(&chain_cmd.command, args_to_use)
 1048|      3|                .unwrap_or({
 1049|      3|                    // Command failed to execute (e.g., program not found)
 1050|      3|                    // Treat this as exit code 127 (command not found) and continue
 1051|      3|                    127
 1052|      3|                });
 1053|       |        }
 1054|       |
 1055|      1|        println!(
 1056|      1|            "{}Sequential command chain completed{}",
 1057|       |            COLOR_GREEN, COLOR_RESET
 1058|       |        );
 1059|      1|        Ok(())
 1060|      1|    }
 1061|       |
 1062|      1|    fn execute_parallel_chain(
 1063|      1|        &self,
 1064|      1|        chain: &CommandChain,
 1065|      1|        additional_args: &[String],
 1066|      1|    ) -> Result<(), String> {
 1067|       |        use std::sync::mpsc;
 1068|       |        use std::thread;
 1069|       |
 1070|      1|        println!(
 1071|      1|            "{}Executing {} commands in parallel{}",
 1072|       |            COLOR_CYAN,
 1073|      1|            chain.commands.len(),
 1074|       |            COLOR_RESET
 1075|       |        );
 1076|       |
 1077|      1|        let (tx, rx) = mpsc::channel();
 1078|      1|        let mut handles = Vec::new();
 1079|       |
 1080|      3|        for (index, chain_cmd) in chain.commands.iter().enumerate() {
                                                ^1                    ^1
 1081|      3|            let cmd = chain_cmd.command.clone();
 1082|      3|            let cmd_display = cmd.clone(); // Clone for display purposes
 1083|       |                                           // If any command in the chain has parameter variables, pass args to all commands
 1084|       |                                           // Otherwise, only pass args to the last command (backward compatibility)
 1085|      3|            let has_vars_in_chain = chain
 1086|      3|                .commands
 1087|      3|                .iter()
 1088|      9|                .any(|cmd| Self::has_parameter_variables(&cmd.command));
                               ^3
 1089|      3|            let args = if has_vars_in_chain || index == chain.commands.len() - 1 {
 1090|      1|                additional_args.to_vec()
 1091|       |            } else {
 1092|      2|                Vec::new()
 1093|       |            };
 1094|      3|            let tx = tx.clone();
 1095|      3|            let runner = self.command_runner.clone();
 1096|       |
 1097|      3|            let handle = thread::spawn(move || {
 1098|      3|                let result = AliasManager::execute_with_runner(runner, cmd, args);
 1099|      3|                tx.send((index, result)).unwrap();
 1100|      3|            });
 1101|       |
 1102|      3|            handles.push(handle);
 1103|      3|            println!(
 1104|      3|                "{}Started:{} {}{}{}",
 1105|       |                COLOR_GRAY, COLOR_RESET, COLOR_CYAN, cmd_display, COLOR_RESET
 1106|       |            );
 1107|       |        }
 1108|       |
 1109|      1|        drop(tx); // Close the sender
 1110|       |
 1111|      1|        let mut results = Vec::new();
 1112|      1|        for _ in 0..chain.commands.len() {
 1113|      3|            match rx.recv() {
 1114|      3|                Ok((index, result)) => {
 1115|      3|                    let success = result.is_ok();
 1116|      3|                    results.push((index, result));
 1117|      3|                    if success {
 1118|      2|                        let code = results.last().unwrap().1.as_ref().unwrap();
 1119|      2|                        println!(
 1120|      2|                            "{}Completed [{}]:{} exit code {}",
 1121|      2|                            COLOR_GREEN,
 1122|      2|                            index + 1,
 1123|      2|                            COLOR_RESET,
 1124|      2|                            code
 1125|      2|                        );
 1126|      2|                    } else {
 1127|      1|                        let error = results.last().unwrap().1.as_ref().err().unwrap();
 1128|      1|                        println!(
 1129|      1|                            "{}Failed [{}]:{} {}",
 1130|      1|                            COLOR_YELLOW,
 1131|      1|                            index + 1,
 1132|      1|                            COLOR_RESET,
 1133|      1|                            error
 1134|      1|                        );
 1135|      1|                    }
 1136|       |                }
 1137|      0|                Err(_) => return Err("Failed to receive command results".to_string()),
 1138|       |            }
 1139|       |        }
 1140|       |
 1141|       |        // Wait for all threads to finish
 1142|      4|        for handle in handles {
                          ^3
 1143|      3|            handle.join().map_err(|_| "Thread panicked")?;
                                                                      ^0
 1144|       |        }
 1145|       |
 1146|       |        // Check if any commands failed
 1147|      1|        let failed_commands: Vec<_> = results
 1148|      1|            .iter()
 1149|      3|            .filter(|(_, result)| result.is_err())
                           ^1
 1150|      1|            .collect();
 1151|       |
 1152|      1|        if failed_commands.is_empty() {
 1153|      0|            println!(
 1154|      0|                "{}All parallel commands completed successfully{}",
 1155|       |                COLOR_GREEN, COLOR_RESET
 1156|       |            );
 1157|      0|            Ok(())
 1158|       |        } else {
 1159|      1|            eprintln!(
 1160|      1|                "{}Failed commands: {}/{}{}",
 1161|       |                COLOR_YELLOW,
 1162|      1|                failed_commands.len(),
 1163|      1|                chain.commands.len(),
 1164|       |                COLOR_RESET
 1165|       |            );
 1166|      1|            Err(format!(
 1167|      1|                "{} parallel commands failed",
 1168|      1|                failed_commands.len()
 1169|      1|            ))
 1170|       |        }
 1171|      1|    }
 1172|       |
 1173|      5|    fn execute_single_command_with_exit_code(
 1174|      5|        &self,
 1175|      5|        command_str: &str,
 1176|      5|        args: &[String],
 1177|      5|    ) -> Result<i32, String> {
 1178|      5|        let (program, command_args) = Self::prepare_command_invocation(command_str, args)?;
                                                                                                       ^0
 1179|       |
 1180|      5|        self.command_runner.run(&program, &command_args)
 1181|      5|    }
 1182|       |
 1183|      1|    fn execute_single_command(&self, command_str: &str, args: &[String]) -> Result<(), String> {
 1184|      1|        let (program, command_args) = Self::prepare_command_invocation(command_str, args)?;
                                                                                                       ^0
 1185|       |
 1186|      1|        let exit_code = self.command_runner.run(&program, &command_args)?;
                                                                                      ^0
 1187|       |
 1188|      1|        if exit_code != 0 {
 1189|      0|            std::process::exit(exit_code);
 1190|      1|        }
 1191|       |
 1192|      1|        Ok(())
 1193|      1|    }
 1194|       |
 1195|      3|    fn execute_with_runner(
 1196|      3|        runner: Arc<dyn CommandRunner + Send + Sync>,
 1197|      3|        command_str: String,
 1198|      3|        args: Vec<String>,
 1199|      3|    ) -> Result<i32, String> {
 1200|      3|        let (program, command_args) =
 1201|      3|            AliasManager::prepare_command_invocation(&command_str, &args)?;
                                                                                       ^0
 1202|      3|        runner.run(&program, &command_args)
 1203|      3|    }
 1204|     10|    fn prepare_command_invocation(
 1205|     10|        command_str: &str,
 1206|     10|        args: &[String],
 1207|     10|    ) -> Result<(String, Vec<String>), String> {
 1208|     10|        let has_params = Self::has_parameter_variables(command_str);
 1209|     10|        let resolved_command = if has_params {
 1210|      0|            Self::substitute_parameters(command_str, args)
 1211|       |        } else {
 1212|     10|            command_str.to_string()
 1213|       |        };
 1214|       |
 1215|     10|        let mut tokens = shell_words::split(&resolved_command)
 1216|     10|            .map_err(|e| format!("Failed to parse command '{}': {}", resolved_command, e))?;
                                               ^0                                                       ^0
 1217|       |
 1218|     10|        if tokens.is_empty() {
 1219|      0|            return Err("Empty command in alias".to_string());
 1220|     10|        }
 1221|       |
 1222|     10|        let program = tokens.remove(0);
 1223|       |
 1224|     10|        if !has_params {
 1225|     10|            tokens.extend(args.iter().cloned());
 1226|     10|        }
                      ^0
 1227|       |
 1228|     10|        Ok((program, tokens))
 1229|     10|    }
 1230|     23|    fn substitute_parameters(command: &str, args: &[String]) -> String {
 1231|     23|        let mut result = String::new();
 1232|     23|        let mut chars = command.chars().peekable();
 1233|       |
 1234|    236|        while let Some(ch) = chars.next() {
                                     ^213
 1235|    213|            if ch == '$' {
 1236|     32|                if let Some(&next_ch) = chars.peek() {
                                           ^31
 1237|     31|                    match next_ch {
 1238|      3|                        '$' => {
 1239|      3|                            // $$ -> literal $
 1240|      3|                            chars.next(); // consume the second $
 1241|      3|                            result.push('$');
 1242|      3|                        }
 1243|      3|                        '@' => {
 1244|      3|                            // $@ -> all arguments as separate parameters (space-separated)
 1245|      3|                            chars.next(); // consume the @
 1246|      3|                            result.push_str(&args.join(" "));
 1247|      3|                        }
 1248|      2|                        '*' => {
 1249|      2|                            // $* -> all arguments as single string (space-separated)
 1250|      2|                            chars.next(); // consume the *
 1251|      2|                            result.push_str(&args.join(" "));
 1252|      2|                        }
 1253|     23|                        '0'..='9' => {
 1254|       |                            // $N -> Nth argument (1-indexed), support multi-digit
 1255|     21|                            let mut number = String::new();
 1256|     44|                            while let Some(&digit_ch) = chars.peek() {
                                                          ^32
 1257|     32|                                if digit_ch.is_ascii_digit() {
 1258|     23|                                    number.push(digit_ch);
 1259|     23|                                    chars.next();
 1260|     23|                                } else {
 1261|      9|                                    break;
 1262|       |                                }
 1263|       |                            }
 1264|       |
 1265|     21|                            if let Ok(index) = number.parse::<usize>() {
 1266|     21|                                if index > 0 && index <= args.len() {
                                                              ^20
 1267|     19|                                    result.push_str(&args[index - 1]);
 1268|     19|                                }
                                              ^2
 1269|       |                                // If index is 0 or out of bounds, substitute with empty string
 1270|      0|                            }
 1271|       |                        }
 1272|      2|                        _ => {
 1273|      2|                            // $ followed by non-special character, treat as literal
 1274|      2|                            result.push(ch);
 1275|      2|                        }
 1276|       |                    }
 1277|      1|                } else {
 1278|      1|                    // $ at end of string, treat as literal
 1279|      1|                    result.push(ch);
 1280|      1|                }
 1281|    181|            } else {
 1282|    181|                result.push(ch);
 1283|    181|            }
 1284|       |        }
 1285|       |
 1286|     23|        result
 1287|     23|    }
 1288|       |
 1289|     42|    fn has_parameter_variables(command: &str) -> bool {
 1290|     42|        let mut chars = command.chars().peekable();
 1291|       |
 1292|    476|        while let Some(ch) = chars.next() {
                                     ^440
 1293|    440|            if ch == '$' {
 1294|     11|                if let Some(&next_ch) = chars.peek() {
                                           ^10
 1295|     10|                    match next_ch {
 1296|      2|                        '$' => {
 1297|      2|                            chars.next(); // consume the second $
 1298|      2|                        }
 1299|       |                        '@' | '*' => {
 1300|      2|                            return true;
 1301|       |                        }
 1302|      6|                        '0'..='9' => {
 1303|      4|                            return true;
 1304|       |                        }
 1305|      2|                        _ => {}
 1306|       |                    }
 1307|      1|                }
 1308|    429|            }
 1309|       |        }
 1310|       |
 1311|     36|        false
 1312|     42|    }
 1313|       |}
 1314|       |
 1315|      2|fn print_help(show_examples: bool) {
 1316|       |    // Main help content
 1317|      2|    println!(
 1318|      2|        "{}{}ðŸš€ Alias Manager v{} - Cross-platform command alias tool{}",
 1319|       |        COLOR_BOLD, COLOR_CYAN, VERSION, COLOR_RESET
 1320|       |    );
 1321|      2|    println!();
 1322|       |
 1323|      2|    println!("{}ðŸ“‹ USAGE:{}", COLOR_BOLD, COLOR_RESET);
 1324|      2|    println!(
 1325|      2|        "  {}a{} {}[alias_name] [args...]{}     Execute an alias",
 1326|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1327|       |    );
 1328|      2|    println!(
 1329|      2|        "  {}a{} {}--add <n> <command> [OPTIONS]{}",
 1330|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1331|       |    );
 1332|      2|    println!(
 1333|      2|        "  {}a{} {}--list [filter]{}            List aliases (optionally filtered)",
 1334|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1335|       |    );
 1336|      2|    println!(
 1337|      2|        "  {}a{} {}--remove <n>{}               Remove an alias",
 1338|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1339|       |    );
 1340|      2|    println!(
 1341|      2|        "  {}a{} {}--which <n>{}                Show what an alias does",
 1342|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1343|       |    );
 1344|      2|    println!(
 1345|      2|        "  {}a{} {}--config{}                   Show config file location",
 1346|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1347|       |    );
 1348|      2|    println!(
 1349|      2|        "  {}a{} {}--export [dir]{}             Export config to directory (default: current)",
 1350|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1351|       |    );
 1352|      2|    println!(
 1353|      2|        "  {}a{} {}--push{}                     Push config to GitHub (repo fixed)",
 1354|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1355|       |    );
 1356|      2|    println!(
 1357|      2|        "  {}a{} {}--pull{}                     Pull config from GitHub (repo fixed)",
 1358|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1359|       |    );
 1360|      2|    println!(
 1361|      2|        "  {}a{} {}--version{}                  Show version information",
 1362|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1363|       |    );
 1364|      2|    println!(
 1365|      2|        "  {}a{} {}--help{}                     Show this help",
 1366|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1367|       |    );
 1368|      2|    println!(
 1369|      2|        "  {}a{} {}--help --examples{}          Show help with detailed examples",
 1370|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1371|       |    );
 1372|      2|    println!();
 1373|       |
 1374|      2|    println!("{}âš™ï¸  ADD OPTIONS:{}", COLOR_BOLD, COLOR_RESET);
 1375|      2|    println!(
 1376|      2|        "  {}--desc{} {}\"description\"{}        Add a description",
 1377|       |        COLOR_YELLOW, COLOR_RESET, COLOR_GRAY, COLOR_RESET
 1378|       |    );
 1379|      2|    println!(
 1380|      2|        "  {}--force{}                      Overwrite existing alias without confirmation",
 1381|       |        COLOR_YELLOW, COLOR_RESET
 1382|       |    );
 1383|      2|    println!(
 1384|      2|        "  {}--chain{} {}<command>{}            Legacy: Chain with && (same as --and)",
 1385|       |        COLOR_YELLOW, COLOR_RESET, COLOR_GRAY, COLOR_RESET
 1386|       |    );
 1387|      2|    println!();
 1388|       |
 1389|      2|    println!("{}ðŸ”— CHAINING OPERATORS:{}", COLOR_BOLD, COLOR_RESET);
 1390|      2|    println!(
 1391|      2|        "  {}--and{} {}<command>{}              Chain command (run if previous succeeded)",
 1392|       |        COLOR_GREEN, COLOR_RESET, COLOR_GRAY, COLOR_RESET
 1393|       |    );
 1394|      2|    println!(
 1395|      2|        "  {}--or{} {}<command>{}               Chain command (run if previous failed)",
 1396|       |        COLOR_YELLOW, COLOR_RESET, COLOR_GRAY, COLOR_RESET
 1397|       |    );
 1398|      2|    println!(
 1399|      2|        "  {}--always{} {}<command>{}           Chain command (always run regardless)",
 1400|       |        COLOR_BLUE, COLOR_RESET, COLOR_GRAY, COLOR_RESET
 1401|       |    );
 1402|      2|    println!(
 1403|      2|        "  {}--if-code{} {}<N> <command>{}      Chain command (run if previous exit code = N)",
 1404|       |        COLOR_CYAN, COLOR_RESET, COLOR_GRAY, COLOR_RESET
 1405|       |    );
 1406|      2|    println!(
 1407|      2|        "  {}--parallel{}                   Execute all commands in parallel",
 1408|       |        COLOR_CYAN, COLOR_RESET
 1409|       |    );
 1410|      2|    println!();
 1411|       |
 1412|      2|    println!("{}ðŸ“‹ PARAMETER SUBSTITUTION:{}", COLOR_BOLD, COLOR_RESET);
 1413|      2|    println!(
 1414|      2|        "  {}$1, $2, $3...{}               Substitute with 1st, 2nd, 3rd argument",
 1415|       |        COLOR_GREEN, COLOR_RESET
 1416|       |    );
 1417|      2|    println!(
 1418|      2|        "  {}$@{}                          Substitute with all arguments",
 1419|       |        COLOR_GREEN, COLOR_RESET
 1420|       |    );
 1421|      2|    println!(
 1422|      2|        "  {}$*{}                          Substitute with all arguments",
 1423|       |        COLOR_GREEN, COLOR_RESET
 1424|       |    );
 1425|      2|    println!(
 1426|      2|        "  {}$${}                          Literal dollar sign",
 1427|       |        COLOR_GREEN, COLOR_RESET
 1428|       |    );
 1429|      2|    println!();
 1430|       |
 1431|      2|    if show_examples {
 1432|      1|        print_examples();
 1433|      1|    } else {
 1434|      1|        println!(
 1435|      1|            "{}ðŸ’¡ Tip:{} Run {}a --help --examples{} to view detailed workflows",
 1436|      1|            COLOR_CYAN, COLOR_RESET, COLOR_GREEN, COLOR_RESET
 1437|      1|        );
 1438|      1|    }
 1439|      2|}
 1440|       |
 1441|      1|fn print_examples() {
 1442|      1|    println!();
 1443|      1|    println!("{}ðŸ“– EXAMPLES:{}", COLOR_BOLD, COLOR_RESET);
 1444|      1|    println!();
 1445|       |
 1446|      1|    println!("  {}# Simple alias{}", COLOR_GRAY, COLOR_RESET);
 1447|      1|    println!(
 1448|      1|        "  {}a --add{} gst {}\"git status\"{} {}--desc{} {}\"Quick git status\"{}",
 1449|       |        COLOR_GREEN,
 1450|       |        COLOR_RESET,
 1451|       |        COLOR_BLUE,
 1452|       |        COLOR_RESET,
 1453|       |        COLOR_YELLOW,
 1454|       |        COLOR_RESET,
 1455|       |        COLOR_GRAY,
 1456|       |        COLOR_RESET
 1457|       |    );
 1458|      1|    println!();
 1459|       |
 1460|      1|    println!(
 1461|      1|        "  {}# Sequential execution (default){}",
 1462|       |        COLOR_GRAY, COLOR_RESET
 1463|       |    );
 1464|      1|    println!("  {}a --add{} deploy {}\"npm run build\"{} {}--and{} {}\"npm test\"{} {}--and{} {}\"npm run deploy\"{}", 
 1465|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1466|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1467|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET);
 1468|      1|    println!();
 1469|       |
 1470|      1|    println!("  {}# Complex conditional logic{}", COLOR_GRAY, COLOR_RESET);
 1471|      1|    println!("  {}a --add{} smart {}\"npm test\"{} {}--and{} {}\"npm run deploy\"{} {}--or{} {}\"echo 'Tests failed!'\"{}", 
 1472|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1473|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1474|       |             COLOR_YELLOW, COLOR_RESET, COLOR_BLUE, COLOR_RESET);
 1475|      1|    println!();
 1476|       |
 1477|      1|    println!("  {}# Exit code handling{}", COLOR_GRAY, COLOR_RESET);
 1478|      1|    println!("  {}a --add{} check {}\"npm test\"{} {}--if-code{} {}0{} {}\"echo 'All good!'\"{} {}--if-code{} {}1{} {}\"echo 'Tests failed'\"{}", 
 1479|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1480|       |             COLOR_CYAN, COLOR_RESET, COLOR_YELLOW, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1481|       |             COLOR_CYAN, COLOR_RESET, COLOR_YELLOW, COLOR_RESET, COLOR_BLUE, COLOR_RESET);
 1482|      1|    println!();
 1483|       |
 1484|      1|    println!("  {}# Parallel execution{}", COLOR_GRAY, COLOR_RESET);
 1485|      1|    println!(
 1486|      1|        "  {}a --add{} build {}\"npm run lint\"{} {}--and{} {}\"npm run test\"{} {}--parallel{}",
 1487|       |        COLOR_GREEN,
 1488|       |        COLOR_RESET,
 1489|       |        COLOR_BLUE,
 1490|       |        COLOR_RESET,
 1491|       |        COLOR_GREEN,
 1492|       |        COLOR_RESET,
 1493|       |        COLOR_BLUE,
 1494|       |        COLOR_RESET,
 1495|       |        COLOR_CYAN,
 1496|       |        COLOR_RESET
 1497|       |    );
 1498|      1|    println!();
 1499|       |
 1500|      1|    println!("  {}# Always run cleanup{}", COLOR_GRAY, COLOR_RESET);
 1501|      1|    println!("  {}a --add{} deploy {}\"npm run build\"{} {}--and{} {}\"npm run deploy\"{} {}--always{} {}\"npm run cleanup\"{}", 
 1502|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1503|       |             COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET,
 1504|       |             COLOR_BLUE, COLOR_RESET, COLOR_BLUE, COLOR_RESET);
 1505|      1|    println!();
 1506|       |
 1507|      1|    println!("  {}# Parameter substitution{}", COLOR_GRAY, COLOR_RESET);
 1508|      1|    println!(
 1509|      1|        "  {}a --add{} tag-push {}\"git tag $1\"{} {}--and{} {}\"git push origin $1\"{}",
 1510|       |        COLOR_GREEN,
 1511|       |        COLOR_RESET,
 1512|       |        COLOR_BLUE,
 1513|       |        COLOR_RESET,
 1514|       |        COLOR_GREEN,
 1515|       |        COLOR_RESET,
 1516|       |        COLOR_BLUE,
 1517|       |        COLOR_RESET
 1518|       |    );
 1519|      1|    println!("  {}a{} tag-push {}v1.2.3{}               # Runs: git tag v1.2.3 && git push origin v1.2.3", 
 1520|       |             COLOR_GREEN, COLOR_RESET, COLOR_YELLOW, COLOR_RESET);
 1521|      1|    println!();
 1522|       |
 1523|      1|    println!("  {}# Multiple parameters{}", COLOR_GRAY, COLOR_RESET);
 1524|      1|    println!(
 1525|      1|        "  {}a --add{} deploy {}\"docker tag $1:$2\"{} {}--and{} {}\"docker push $1:$2\"{}",
 1526|       |        COLOR_GREEN,
 1527|       |        COLOR_RESET,
 1528|       |        COLOR_BLUE,
 1529|       |        COLOR_RESET,
 1530|       |        COLOR_GREEN,
 1531|       |        COLOR_RESET,
 1532|       |        COLOR_BLUE,
 1533|       |        COLOR_RESET
 1534|       |    );
 1535|      1|    println!("  {}a{} deploy {}myapp latest{}           # Runs: docker tag myapp:latest && docker push myapp:latest", 
 1536|       |             COLOR_GREEN, COLOR_RESET, COLOR_YELLOW, COLOR_RESET);
 1537|      1|    println!();
 1538|       |
 1539|      1|    println!("  {}# All arguments with $@{}", COLOR_GRAY, COLOR_RESET);
 1540|      1|    println!(
 1541|      1|        "  {}a --add{} test-files {}\"pytest $@\"{}",
 1542|       |        COLOR_GREEN, COLOR_RESET, COLOR_BLUE, COLOR_RESET
 1543|       |    );
 1544|      1|    println!(
 1545|      1|        "  {}a{} test-files {}test1.py test2.py{}   # Runs: pytest test1.py test2.py",
 1546|       |        COLOR_GREEN, COLOR_RESET, COLOR_YELLOW, COLOR_RESET
 1547|       |    );
 1548|      1|    println!();
 1549|       |
 1550|      1|    println!("{}ðŸŽ¯ Pro Tips:{}", COLOR_BOLD, COLOR_RESET);
 1551|      1|    println!(
 1552|      1|        "  â€¢ Use {}$1, $2, $3{} to pass arguments to multiple commands in a chain",
 1553|       |        COLOR_GREEN, COLOR_RESET
 1554|       |    );
 1555|      1|    println!(
 1556|      1|        "  â€¢ Use {}$@{} to pass all arguments when you don't know how many there will be",
 1557|       |        COLOR_GREEN, COLOR_RESET
 1558|       |    );
 1559|      1|    println!(
 1560|      1|        "  â€¢ Use {}--parallel{} for independent tasks that can run simultaneously",
 1561|       |        COLOR_CYAN, COLOR_RESET
 1562|       |    );
 1563|      1|    println!(
 1564|      1|        "  â€¢ Combine {}--and{} and {}--or{} for robust deployment workflows",
 1565|       |        COLOR_GREEN, COLOR_RESET, COLOR_YELLOW, COLOR_RESET
 1566|       |    );
 1567|      1|    println!(
 1568|      1|        "  â€¢ Use {}--always{} for cleanup tasks that must run regardless",
 1569|       |        COLOR_BLUE, COLOR_RESET
 1570|       |    );
 1571|      1|    println!(
 1572|      1|        "  â€¢ {}--if-code{} enables sophisticated conditional logic",
 1573|       |        COLOR_CYAN, COLOR_RESET
 1574|       |    );
 1575|      1|}
 1576|       |
 1577|      1|fn print_version() {
 1578|      1|    println!(
 1579|      1|        "{}{}ðŸš€ Alias Manager v{}{}",
 1580|       |        COLOR_BOLD, COLOR_CYAN, VERSION, COLOR_RESET
 1581|       |    );
 1582|      1|    println!(
 1583|      1|        "{}âš¡ A cross-platform command alias management tool written in Rust{}",
 1584|       |        COLOR_GRAY, COLOR_RESET
 1585|       |    );
 1586|      1|    println!("{}ðŸ”— Features: Advanced chaining, parallel execution, conditional logic, parameter substitution{}", COLOR_BLUE, COLOR_RESET);
 1587|      1|}
 1588|       |
 1589|     13|fn main() {
 1590|     13|    let args: Vec<String> = env::args().collect();
 1591|       |
 1592|     13|    if args.len() < 2 {
 1593|      1|        print_help(false);
 1594|      1|        return;
 1595|     12|    }
 1596|       |
 1597|     12|    let mut manager = match AliasManager::new() {
                      ^11
 1598|     11|        Ok(mgr) => mgr,
 1599|      1|        Err(e) => {
 1600|      1|            eprintln!(
 1601|      1|                "{}Error initializing alias manager:{} {}",
 1602|       |                COLOR_YELLOW, COLOR_RESET, e
 1603|       |            );
 1604|      1|            std::process::exit(1);
 1605|       |        }
 1606|       |    };
 1607|       |
 1608|     11|    match args[1].as_str() {
 1609|     11|        "--help" | "-h" => {
                                 ^9
 1610|      2|            let mut show_examples = false;
 1611|      2|            for extra in &args[2..] {
 1612|      2|                match extra.as_str() {
 1613|      2|                    "--examples" => show_examples = true,
                                                  ^1
 1614|      1|                    "--no-examples" => show_examples = false,
                                                     ^0
 1615|       |                    _ => {
 1616|      1|                        eprintln!(
 1617|      1|                            "{}Unknown option for --help:{} {}",
 1618|       |                            COLOR_YELLOW, COLOR_RESET, extra
 1619|       |                        );
 1620|      1|                        std::process::exit(1);
 1621|       |                    }
 1622|       |                }
 1623|       |            }
 1624|      1|            print_help(show_examples);
 1625|       |        }
 1626|       |
 1627|      9|        "--version" | "-v" => {
                                    ^8
 1628|      1|            print_version();
 1629|      1|        }
 1630|       |
 1631|      8|        "--config" => {
 1632|      1|            manager.show_config_location();
 1633|      1|        }
 1634|       |
 1635|      7|        "--export" => {
 1636|      1|            let target_path = if args.len() > 2 {
 1637|      0|                Some(args[2].as_str())
 1638|       |            } else {
 1639|      1|                None
 1640|       |            };
 1641|       |
 1642|      1|            match manager.export_config(target_path) {
 1643|      0|                Ok(()) => {}
 1644|      1|                Err(e) => {
 1645|      1|                    eprintln!(
 1646|      1|                        "{}Error exporting config:{} {}",
 1647|       |                        COLOR_YELLOW, COLOR_RESET, e
 1648|       |                    );
 1649|      1|                    std::process::exit(1);
 1650|       |                }
 1651|       |            }
 1652|       |        }
 1653|       |
 1654|      6|        "--push" => {
 1655|       |            // Optional: allow custom commit message only
 1656|      2|            let mut message: Option<String> = None;
 1657|      2|            let mut i = 2;
 1658|      3|            while i < args.len() {
 1659|      1|                match args[i].as_str() {
 1660|      1|                    "--message" if i + 1 < args.len() => {
 1661|      1|                        message = Some(args[i + 1].clone());
 1662|      1|                        i += 2;
 1663|      1|                    }
 1664|       |                    _ => {
 1665|      0|                        eprintln!(
 1666|      0|                            "{}Unknown or unsupported option for --push:{} {}",
 1667|      0|                            COLOR_YELLOW, COLOR_RESET, args[i]
 1668|       |                        );
 1669|      0|                        std::process::exit(1);
 1670|       |                    }
 1671|       |                }
 1672|       |            }
 1673|       |
 1674|      2|            match manager.push_config_to_github(message.as_deref()) {
 1675|      0|                Ok(()) => {}
 1676|      2|                Err(e) => {
 1677|      2|                    eprintln!("{}Error pushing config:{} {}", COLOR_YELLOW, COLOR_RESET, e);
 1678|      2|                    std::process::exit(1);
 1679|       |                }
 1680|       |            }
 1681|       |        }
 1682|       |
 1683|      4|        "--pull" => {
 1684|      1|            if args.len() > 2 {
 1685|      1|                eprintln!(
 1686|      1|                    "{}--pull does not accept options; repo is fixed.{}",
 1687|       |                    COLOR_YELLOW, COLOR_RESET
 1688|       |                );
 1689|      1|                std::process::exit(1);
 1690|      0|            }
 1691|       |
 1692|      0|            match manager.pull_config_from_github() {
 1693|      0|                Ok(()) => {}
 1694|      0|                Err(e) => {
 1695|      0|                    eprintln!("{}Error pulling config:{} {}", COLOR_YELLOW, COLOR_RESET, e);
 1696|      0|                    std::process::exit(1);
 1697|       |                }
 1698|       |            }
 1699|       |        }
 1700|       |
 1701|      3|        "--add" => {
 1702|      0|            if args.len() < 4 {
 1703|      0|                eprintln!(
 1704|      0|                    "{}Usage:{} a --add <n> <command> [OPTIONS]",
 1705|       |                    COLOR_YELLOW, COLOR_RESET
 1706|       |                );
 1707|      0|                std::process::exit(1);
 1708|      0|            }
 1709|       |
 1710|      0|            let name = args[2].clone();
 1711|      0|            let first_command = args[3].clone();
 1712|       |
 1713|      0|            let mut description = None;
 1714|      0|            let mut force = false;
 1715|      0|            let mut parallel = false;
 1716|      0|            let mut commands = vec![ChainCommand {
 1717|      0|                command: first_command,
 1718|      0|                operator: None, // First command has no operator
 1719|      0|            }];
 1720|       |
 1721|      0|            let mut i = 4;
 1722|      0|            while i < args.len() {
 1723|      0|                match args[i].as_str() {
 1724|      0|                    "--desc" => {
 1725|      0|                        if i + 1 < args.len() {
 1726|      0|                            description = Some(args[i + 1].clone());
 1727|      0|                            i += 2;
 1728|      0|                        } else {
 1729|      0|                            eprintln!(
 1730|      0|                                "{}Error:{} --desc requires a description",
 1731|       |                                COLOR_YELLOW, COLOR_RESET
 1732|       |                            );
 1733|      0|                            std::process::exit(1);
 1734|       |                        }
 1735|       |                    }
 1736|      0|                    "--force" => {
 1737|      0|                        force = true;
 1738|      0|                        i += 1;
 1739|      0|                    }
 1740|      0|                    "--parallel" => {
 1741|      0|                        parallel = true;
 1742|      0|                        i += 1;
 1743|      0|                    }
 1744|      0|                    "--chain" | "--and" => {
 1745|      0|                        if i + 1 < args.len() {
 1746|      0|                            commands.push(ChainCommand {
 1747|      0|                                command: args[i + 1].clone(),
 1748|      0|                                operator: Some(ChainOperator::And),
 1749|      0|                            });
 1750|      0|                            i += 2;
 1751|      0|                        } else {
 1752|      0|                            eprintln!(
 1753|      0|                                "{}Error:{} {} requires a command",
 1754|      0|                                COLOR_YELLOW, COLOR_RESET, args[i]
 1755|       |                            );
 1756|      0|                            std::process::exit(1);
 1757|       |                        }
 1758|       |                    }
 1759|      0|                    "--or" => {
 1760|      0|                        if i + 1 < args.len() {
 1761|      0|                            commands.push(ChainCommand {
 1762|      0|                                command: args[i + 1].clone(),
 1763|      0|                                operator: Some(ChainOperator::Or),
 1764|      0|                            });
 1765|      0|                            i += 2;
 1766|      0|                        } else {
 1767|      0|                            eprintln!(
 1768|      0|                                "{}Error:{} --or requires a command",
 1769|       |                                COLOR_YELLOW, COLOR_RESET
 1770|       |                            );
 1771|      0|                            std::process::exit(1);
 1772|       |                        }
 1773|       |                    }
 1774|      0|                    "--always" => {
 1775|      0|                        if i + 1 < args.len() {
 1776|      0|                            commands.push(ChainCommand {
 1777|      0|                                command: args[i + 1].clone(),
 1778|      0|                                operator: Some(ChainOperator::Always),
 1779|      0|                            });
 1780|      0|                            i += 2;
 1781|      0|                        } else {
 1782|      0|                            eprintln!(
 1783|      0|                                "{}Error:{} --always requires a command",
 1784|       |                                COLOR_YELLOW, COLOR_RESET
 1785|       |                            );
 1786|      0|                            std::process::exit(1);
 1787|       |                        }
 1788|       |                    }
 1789|      0|                    "--if-code" => {
 1790|      0|                        if i + 2 < args.len() {
 1791|      0|                            match args[i + 1].parse::<i32>() {
 1792|      0|                                Ok(code) => {
 1793|      0|                                    commands.push(ChainCommand {
 1794|      0|                                        command: args[i + 2].clone(),
 1795|      0|                                        operator: Some(ChainOperator::IfCode(code)),
 1796|      0|                                    });
 1797|      0|                                    i += 3;
 1798|      0|                                }
 1799|       |                                Err(_) => {
 1800|      0|                                    eprintln!(
 1801|      0|                                        "{}Error:{} --if-code requires a numeric exit code",
 1802|       |                                        COLOR_YELLOW, COLOR_RESET
 1803|       |                                    );
 1804|      0|                                    std::process::exit(1);
 1805|       |                                }
 1806|       |                            }
 1807|       |                        } else {
 1808|      0|                            eprintln!(
 1809|      0|                                "{}Error:{} --if-code requires an exit code and a command",
 1810|       |                                COLOR_YELLOW, COLOR_RESET
 1811|       |                            );
 1812|      0|                            std::process::exit(1);
 1813|       |                        }
 1814|       |                    }
 1815|       |                    _ => {
 1816|      0|                        eprintln!(
 1817|      0|                            "{}Error:{} Unknown option '{}'",
 1818|      0|                            COLOR_YELLOW, COLOR_RESET, args[i]
 1819|       |                        );
 1820|      0|                        std::process::exit(1);
 1821|       |                    }
 1822|       |                }
 1823|       |            }
 1824|       |
 1825|       |            // Determine if we should create a simple or complex command
 1826|      0|            let command_type = if commands.len() == 1 && !parallel {
 1827|       |                // Single command, use simple type for backward compatibility
 1828|      0|                CommandType::Simple(commands[0].command.clone())
 1829|       |            } else {
 1830|       |                // Multiple commands or parallel execution, use chain type
 1831|      0|                CommandType::Chain(CommandChain { commands, parallel })
 1832|       |            };
 1833|       |
 1834|      0|            match manager.add_alias(name.clone(), command_type, description, force) {
 1835|      0|                Ok(()) => {}
 1836|      0|                Err(e) => {
 1837|      0|                    eprintln!("{}Error adding alias:{} {}", COLOR_YELLOW, COLOR_RESET, e);
 1838|      0|                    std::process::exit(1);
 1839|       |                }
 1840|       |            }
 1841|       |        }
 1842|       |
 1843|      3|        "--list" => {
 1844|      2|            let filter = if args.len() > 2 {
 1845|      1|                Some(args[2].as_str())
 1846|       |            } else {
 1847|      1|                None
 1848|       |            };
 1849|      2|            manager.list_aliases(filter);
 1850|       |        }
 1851|       |
 1852|      1|        "--remove" => {
 1853|      0|            if args.len() < 3 {
 1854|      0|                eprintln!("{}Usage:{} a --remove <n>", COLOR_YELLOW, COLOR_RESET);
 1855|      0|                std::process::exit(1);
 1856|      0|            }
 1857|       |
 1858|      0|            match manager.remove_alias(&args[2]) {
 1859|      0|                Ok(()) => println!("{}Removed alias '{}'{}", COLOR_GREEN, args[2], COLOR_RESET),
 1860|      0|                Err(e) => {
 1861|      0|                    eprintln!("{}Error removing alias:{} {}", COLOR_YELLOW, COLOR_RESET, e);
 1862|      0|                    std::process::exit(1);
 1863|       |                }
 1864|       |            }
 1865|       |        }
 1866|       |
 1867|      1|        "--which" => {
 1868|      1|            if args.len() < 3 {
 1869|      0|                eprintln!("{}Usage:{} a --which <n>", COLOR_YELLOW, COLOR_RESET);
 1870|      0|                std::process::exit(1);
 1871|      1|            }
 1872|       |
 1873|      1|            manager.which_alias(&args[2]);
 1874|       |        }
 1875|       |
 1876|      0|        alias_name => {
 1877|      0|            let alias_args = if args.len() > 2 { &args[2..] } else { &[] };
 1878|       |
 1879|      0|            match manager.execute_alias(alias_name, alias_args) {
 1880|      0|                Ok(()) => {}
 1881|      0|                Err(e) => {
 1882|      0|                    eprintln!(
 1883|      0|                        "{}Error executing alias:{} {}",
 1884|       |                        COLOR_YELLOW, COLOR_RESET, e
 1885|       |                    );
 1886|      0|                    std::process::exit(1);
 1887|       |                }
 1888|       |            }
 1889|       |        }
 1890|       |    }
 1891|      7|}
 1892|       |
 1893|       |#[cfg(test)]
 1894|       |mod tests {
 1895|       |    use super::*;
 1896|       |    use std::collections::VecDeque;
 1897|       |    use std::env;
 1898|       |    use std::ffi::{OsStr, OsString};
 1899|       |    use std::io::{self, Cursor, Read, Write};
 1900|       |    use std::net::TcpListener;
 1901|       |    use std::path::{Path, PathBuf};
 1902|       |    use std::sync::{Arc, Mutex, OnceLock};
 1903|       |    use std::thread;
 1904|       |    use std::time::Duration;
 1905|       |    use tempfile::TempDir;
 1906|       |
 1907|       |    #[derive(Default)]
 1908|       |    struct MockCommandRunner {
 1909|       |        calls: Mutex<Vec<(String, Vec<String>)>>,
 1910|       |        responses: Mutex<VecDeque<Result<i32, String>>>,
 1911|       |    }
 1912|       |
 1913|       |    impl MockCommandRunner {
 1914|      2|        fn new() -> Self {
 1915|      2|            Self::default()
 1916|      2|        }
 1917|       |
 1918|     14|        fn with_responses(responses: Vec<Result<i32, String>>) -> Self {
 1919|     14|            Self {
 1920|     14|                calls: Mutex::new(Vec::new()),
 1921|     14|                responses: Mutex::new(VecDeque::from(responses)),
 1922|     14|            }
 1923|     14|        }
 1924|       |
 1925|      1|        fn push_response(&self, response: Result<i32, String>) {
 1926|      1|            self.responses.lock().unwrap().push_back(response);
 1927|      1|        }
 1928|       |
 1929|      3|        fn calls(&self) -> Vec<(String, Vec<String>)> {
 1930|      3|            self.calls.lock().unwrap().clone()
 1931|      3|        }
 1932|       |    }
 1933|       |
 1934|       |    impl CommandRunner for MockCommandRunner {
 1935|      7|        fn run(&self, program: &str, args: &[String]) -> Result<i32, String> {
 1936|      7|            self.calls
 1937|      7|                .lock()
 1938|      7|                .unwrap()
 1939|      7|                .push((program.to_string(), args.to_vec()));
 1940|       |
 1941|      7|            if let Some(result) = self.responses.lock().unwrap().pop_front() {
 1942|      7|                result
 1943|       |            } else {
 1944|      0|                Ok(0)
 1945|       |            }
 1946|      7|        }
 1947|       |    }
 1948|       |
 1949|       |    #[derive(Default)]
 1950|       |    struct MockGitHubClient {
 1951|       |        requests: Mutex<Vec<GitHubRequest>>,
 1952|       |        responses: Mutex<VecDeque<Result<GitHubResponse, String>>>,
 1953|       |    }
 1954|       |
 1955|       |    #[derive(Clone, Debug)]
 1956|       |    struct GitHubRequest {
 1957|       |        method: String,
 1958|       |        _url: String,
 1959|       |        headers: Vec<(String, String)>,
 1960|       |        body: Option<serde_json::Value>,
 1961|       |    }
 1962|       |
 1963|       |    impl MockGitHubClient {
 1964|      4|        fn new() -> Self {
 1965|      4|            Self::default()
 1966|      4|        }
 1967|       |
 1968|     14|        fn with_responses(responses: Vec<Result<GitHubResponse, String>>) -> Self {
 1969|     14|            Self {
 1970|     14|                requests: Mutex::new(Vec::new()),
 1971|     14|                responses: Mutex::new(VecDeque::from(responses)),
 1972|     14|            }
 1973|     14|        }
 1974|       |
 1975|      3|        fn requests(&self) -> Vec<GitHubRequest> {
 1976|      3|            self.requests.lock().unwrap().clone()
 1977|      3|        }
 1978|       |    }
 1979|       |
 1980|       |    impl GitHubClient for MockGitHubClient {
 1981|      5|        fn get(&self, url: &str, headers: &[(&str, String)]) -> Result<GitHubResponse, String> {
 1982|      5|            self.requests.lock().unwrap().push(GitHubRequest {
 1983|      5|                method: "GET".to_string(),
 1984|      5|                _url: url.to_string(),
 1985|      5|                headers: headers
 1986|      5|                    .iter()
 1987|      9|                    .map(|(k, v)| ((*k).to_string(), v.clone()))
                                   ^5
 1988|      5|                    .collect(),
 1989|      5|                body: None,
 1990|       |            });
 1991|       |
 1992|      5|            self.responses
 1993|      5|                .lock()
 1994|      5|                .unwrap()
 1995|      5|                .pop_front()
 1996|      5|                .unwrap_or_else(|| Ok(GitHubResponse::from_status(200)))
                                                    ^0
 1997|      5|        }
 1998|       |
 1999|      3|        fn put(
 2000|      3|            &self,
 2001|      3|            url: &str,
 2002|      3|            headers: &[(&str, String)],
 2003|      3|            body: serde_json::Value,
 2004|      3|        ) -> Result<GitHubResponse, String> {
 2005|      3|            self.requests.lock().unwrap().push(GitHubRequest {
 2006|      3|                method: "PUT".to_string(),
 2007|      3|                _url: url.to_string(),
 2008|      3|                headers: headers
 2009|      3|                    .iter()
 2010|      6|                    .map(|(k, v)| ((*k).to_string(), v.clone()))
                                   ^3
 2011|      3|                    .collect(),
 2012|      3|                body: Some(body.clone()),
 2013|       |            });
 2014|       |
 2015|      3|            self.responses
 2016|      3|                .lock()
 2017|      3|                .unwrap()
 2018|      3|                .pop_front()
 2019|      3|                .unwrap_or_else(|| Ok(GitHubResponse::from_status(200)))
                                                    ^0
 2020|      3|        }
 2021|       |    }
 2022|       |
 2023|      9|    fn env_lock() -> &'static Mutex<()> {
 2024|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 2025|      9|        ENV_LOCK.get_or_init(|| Mutex::new(()))
                                              ^1         ^1
 2026|      9|    }
 2027|       |
 2028|      3|    fn http_response(status: u16, reason: &str, body: &str) -> String {
 2029|      3|        format!(
 2030|      3|            "HTTP/1.1 {} {}\r\nContent-Type: application/json\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
 2031|       |            status,
 2032|       |            reason,
 2033|      3|            body.len(),
 2034|       |            body
 2035|       |        )
 2036|      3|    }
 2037|       |
 2038|      3|    fn spawn_stub_server(responses: Vec<String>) -> (String, thread::JoinHandle<()>) {
 2039|      3|        let listener = TcpListener::bind("127.0.0.1:0").unwrap();
 2040|      3|        let addr = listener.local_addr().unwrap();
 2041|      3|        let handle = thread::spawn(move || {
 2042|      6|            for response in responses {
                              ^3
 2043|      3|                let (mut stream, _) = listener.accept().unwrap();
 2044|      3|                let _ = stream.set_read_timeout(Some(Duration::from_millis(200)));
 2045|      3|                let mut buffer = [0u8; 4096];
 2046|      3|                let _ = stream.read(&mut buffer);
 2047|      3|                stream
 2048|      3|                    .write_all(response.as_bytes())
 2049|      3|                    .expect("send stub response");
 2050|      3|            }
 2051|      3|        });
 2052|      3|        (format!("http://{}", addr), handle)
 2053|      3|    }
 2054|       |
 2055|     14|    fn create_manager_with_mocks(
 2056|     14|        command_responses: Vec<Result<i32, String>>,
 2057|     14|        github_responses: Vec<Result<GitHubResponse, String>>,
 2058|     14|    ) -> (
 2059|     14|        AliasManager,
 2060|     14|        TempDir,
 2061|     14|        Arc<MockCommandRunner>,
 2062|     14|        Arc<MockGitHubClient>,
 2063|     14|    ) {
 2064|     14|        let temp_dir = TempDir::new().unwrap();
 2065|     14|        let config_path = temp_dir.path().join("config.json");
 2066|       |
 2067|     14|        let runner = Arc::new(MockCommandRunner::with_responses(command_responses));
 2068|     14|        let github = Arc::new(MockGitHubClient::with_responses(github_responses));
 2069|       |
 2070|     14|        let runner_trait: Arc<dyn CommandRunner + Send + Sync> = runner.clone();
 2071|     14|        let github_trait: Arc<dyn GitHubClient + Send + Sync> = github.clone();
 2072|       |
 2073|     14|        let manager =
 2074|     14|            AliasManager::with_dependencies(Config::new(), config_path, runner_trait, github_trait);
 2075|       |
 2076|     14|        (manager, temp_dir, runner, github)
 2077|     14|    }
 2078|       |
 2079|      6|    fn create_test_manager() -> (AliasManager, TempDir) {
 2080|      6|        let (manager, temp_dir, _runner, _github) =
 2081|      6|            create_manager_with_mocks(Vec::new(), Vec::new());
 2082|      6|        (manager, temp_dir)
 2083|      6|    }
 2084|       |
 2085|       |    struct WorkingDirGuard {
 2086|       |        original: PathBuf,
 2087|       |    }
 2088|       |
 2089|       |    impl WorkingDirGuard {
 2090|      1|        fn change_to(target: &Path) -> io::Result<Self> {
 2091|      1|            let original = env::current_dir()?;
                                                           ^0
 2092|      1|            env::set_current_dir(target)?;
                                                      ^0
 2093|      1|            Ok(Self { original })
 2094|      1|        }
 2095|       |    }
 2096|       |
 2097|       |    impl Drop for WorkingDirGuard {
 2098|      1|        fn drop(&mut self) {
 2099|      1|            let _ = env::set_current_dir(&self.original);
 2100|      1|        }
 2101|       |    }
 2102|       |
 2103|       |    struct EnvVarGuard {
 2104|       |        key: String,
 2105|       |        original: Option<OsString>,
 2106|       |    }
 2107|       |
 2108|       |    impl EnvVarGuard {
 2109|      9|        fn set<K, V>(key: K, value: V) -> Self
 2110|      9|        where
 2111|      9|            K: Into<String>,
 2112|      9|            V: AsRef<OsStr>,
 2113|       |        {
 2114|      9|            let key_string = key.into();
 2115|      9|            let original = env::var_os(&key_string);
 2116|      9|            env::set_var(&key_string, value.as_ref());
 2117|      9|            Self {
 2118|      9|                key: key_string,
 2119|      9|                original,
 2120|      9|            }
 2121|      9|        }
 2122|       |    }
 2123|       |
 2124|       |    impl Drop for EnvVarGuard {
 2125|      9|        fn drop(&mut self) {
 2126|      9|            match &self.original {
 2127|      1|                Some(val) => env::set_var(&self.key, val),
 2128|      8|                None => env::remove_var(&self.key),
 2129|       |            }
 2130|      9|        }
 2131|       |    }
 2132|       |
 2133|       |    #[test]
 2134|      1|    fn test_config_new() {
 2135|      1|        let config = Config::new();
 2136|      1|        assert!(config.aliases.is_empty());
 2137|      1|    }
 2138|       |
 2139|       |    #[test]
 2140|      1|    fn test_add_alias() {
 2141|      1|        let mut config = Config::new();
 2142|       |
 2143|      1|        let result = config.add_alias(
 2144|      1|            "gst".to_string(),
 2145|      1|            CommandType::Simple("git status".to_string()),
 2146|      1|            Some("Quick status".to_string()),
 2147|       |            false,
 2148|       |        );
 2149|       |
 2150|      1|        assert!(result.is_ok());
 2151|      1|        assert_eq!(config.aliases.len(), 1);
 2152|       |
 2153|      1|        let entry = config.get_alias("gst").unwrap();
 2154|      1|        assert_eq!(entry.command_display(), "git status");
 2155|      1|        assert_eq!(entry.description, Some("Quick status".to_string()));
 2156|      1|    }
 2157|       |
 2158|       |    #[test]
 2159|      1|    fn test_add_alias_reserved_names() {
 2160|      1|        let mut config = Config::new();
 2161|       |
 2162|      1|        let invalid_names = vec!["--add", "mgr:test", ".hidden"];
 2163|       |
 2164|      4|        for name in invalid_names {
                          ^3
 2165|      3|            let result = config.add_alias(
 2166|      3|                name.to_string(),
 2167|      3|                CommandType::Simple("test command".to_string()),
 2168|      3|                None,
 2169|       |                false,
 2170|       |            );
 2171|      3|            assert!(result.is_err());
 2172|       |        }
 2173|      1|    }
 2174|       |
 2175|       |    #[test]
 2176|      1|    fn test_remove_alias() {
 2177|      1|        let mut config = Config::new();
 2178|       |
 2179|      1|        config
 2180|      1|            .add_alias(
 2181|      1|                "test".to_string(),
 2182|      1|                CommandType::Simple("echo test".to_string()),
 2183|      1|                None,
 2184|       |                false,
 2185|       |            )
 2186|      1|            .unwrap();
 2187|      1|        assert_eq!(config.aliases.len(), 1);
 2188|       |
 2189|      1|        let result = config.remove_alias("test");
 2190|      1|        assert!(result.is_ok());
 2191|      1|        assert_eq!(config.aliases.len(), 0);
 2192|       |
 2193|      1|        let result = config.remove_alias("nonexistent");
 2194|      1|        assert!(result.is_err());
 2195|      1|    }
 2196|       |
 2197|       |    #[test]
 2198|      1|    fn test_get_alias() {
 2199|      1|        let mut config = Config::new();
 2200|      1|        config
 2201|      1|            .add_alias(
 2202|      1|                "test".to_string(),
 2203|      1|                CommandType::Simple("echo test".to_string()),
 2204|      1|                None,
 2205|       |                false,
 2206|       |            )
 2207|      1|            .unwrap();
 2208|       |
 2209|      1|        let entry = config.get_alias("test");
 2210|      1|        assert!(entry.is_some());
 2211|      1|        assert_eq!(entry.unwrap().command_display(), "echo test");
 2212|       |
 2213|      1|        let entry = config.get_alias("nonexistent");
 2214|      1|        assert!(entry.is_none());
 2215|      1|    }
 2216|       |
 2217|       |    #[test]
 2218|      1|    fn test_list_aliases() {
 2219|      1|        let mut config = Config::new();
 2220|       |
 2221|      1|        config
 2222|      1|            .add_alias(
 2223|      1|                "gst".to_string(),
 2224|      1|                CommandType::Simple("git status".to_string()),
 2225|      1|                None,
 2226|       |                false,
 2227|       |            )
 2228|      1|            .unwrap();
 2229|      1|        config
 2230|      1|            .add_alias(
 2231|      1|                "glog".to_string(),
 2232|      1|                CommandType::Simple("git log".to_string()),
 2233|      1|                None,
 2234|       |                false,
 2235|       |            )
 2236|      1|            .unwrap();
 2237|      1|        config
 2238|      1|            .add_alias(
 2239|      1|                "deploy".to_string(),
 2240|      1|                CommandType::Simple("docker-compose up".to_string()),
 2241|      1|                None,
 2242|       |                false,
 2243|       |            )
 2244|      1|            .unwrap();
 2245|       |
 2246|      1|        let all_aliases = config.list_aliases(None);
 2247|      1|        assert_eq!(all_aliases.len(), 3);
 2248|       |
 2249|      1|        let git_aliases = config.list_aliases(Some("g"));
 2250|      1|        assert_eq!(git_aliases.len(), 2);
 2251|       |
 2252|      1|        let deploy_aliases = config.list_aliases(Some("deploy"));
 2253|      1|        assert_eq!(deploy_aliases.len(), 1);
 2254|      1|    }
 2255|       |
 2256|       |    #[test]
 2257|      1|    fn test_manager_save_load() {
 2258|      1|        let (mut manager, _temp_dir) = create_test_manager();
 2259|       |
 2260|      1|        manager
 2261|      1|            .add_alias(
 2262|      1|                "test".to_string(),
 2263|      1|                CommandType::Simple("echo hello".to_string()),
 2264|      1|                Some("Test command".to_string()),
 2265|       |                false,
 2266|       |            )
 2267|      1|            .unwrap();
 2268|       |
 2269|       |        // Load a new manager from the saved config
 2270|      1|        let loaded_runner: Arc<dyn CommandRunner + Send + Sync> =
 2271|      1|            Arc::new(MockCommandRunner::new());
 2272|      1|        let loaded_github: Arc<dyn GitHubClient + Send + Sync> = Arc::new(MockGitHubClient::new());
 2273|      1|        let loaded_manager = AliasManager::with_dependencies(
 2274|      1|            AliasManager::load_config(&manager.config_path).unwrap(),
 2275|      1|            manager.config_path.clone(),
 2276|      1|            loaded_runner,
 2277|      1|            loaded_github,
 2278|       |        );
 2279|       |
 2280|      1|        let entry = loaded_manager.config.get_alias("test").unwrap();
 2281|      1|        assert_eq!(entry.command_display(), "echo hello");
 2282|      1|        assert_eq!(entry.description, Some("Test command".to_string()));
 2283|      1|    }
 2284|       |
 2285|       |    #[test]
 2286|      1|    fn test_manager_add_remove() {
 2287|      1|        let (mut manager, _temp_dir) = create_test_manager();
 2288|       |
 2289|      1|        assert!(manager
 2290|      1|            .add_alias(
 2291|      1|                "test".to_string(),
 2292|      1|                CommandType::Simple("echo test".to_string()),
 2293|      1|                None,
 2294|      1|                false
 2295|      1|            )
 2296|      1|            .is_ok());
 2297|      1|        assert!(manager.config.get_alias("test").is_some());
 2298|       |
 2299|      1|        assert!(manager.remove_alias("test").is_ok());
 2300|      1|        assert!(manager.config.get_alias("test").is_none());
 2301|       |
 2302|      1|        assert!(manager.remove_alias("nonexistent").is_err());
 2303|      1|    }
 2304|       |
 2305|       |    #[test]
 2306|      1|    fn test_serialize_deserialize() {
 2307|      1|        let mut config = Config::new();
 2308|      1|        config
 2309|      1|            .add_alias(
 2310|      1|                "test".to_string(),
 2311|      1|                CommandType::Simple("echo test".to_string()),
 2312|      1|                Some("Test".to_string()),
 2313|       |                false,
 2314|       |            )
 2315|      1|            .unwrap();
 2316|       |
 2317|      1|        let json = serde_json::to_string(&config).unwrap();
 2318|      1|        let deserialized: Config = serde_json::from_str(&json).unwrap();
 2319|       |
 2320|      1|        let entry = deserialized.get_alias("test").unwrap();
 2321|      1|        assert_eq!(entry.command_display(), "echo test");
 2322|      1|        assert_eq!(entry.description, Some("Test".to_string()));
 2323|      1|    }
 2324|       |
 2325|       |    #[test]
 2326|      1|    fn test_complex_chain() {
 2327|      1|        let mut config = Config::new();
 2328|       |
 2329|      1|        let chain = CommandChain {
 2330|      1|            commands: vec![
 2331|      1|                ChainCommand {
 2332|      1|                    command: "echo first".to_string(),
 2333|      1|                    operator: None,
 2334|      1|                },
 2335|      1|                ChainCommand {
 2336|      1|                    command: "echo second".to_string(),
 2337|      1|                    operator: Some(ChainOperator::And),
 2338|      1|                },
 2339|      1|                ChainCommand {
 2340|      1|                    command: "echo third".to_string(),
 2341|      1|                    operator: Some(ChainOperator::Or),
 2342|      1|                },
 2343|      1|            ],
 2344|      1|            parallel: false,
 2345|      1|        };
 2346|       |
 2347|      1|        config
 2348|      1|            .add_alias("test".to_string(), CommandType::Chain(chain), None, false)
 2349|      1|            .unwrap();
 2350|       |
 2351|      1|        let entry = config.get_alias("test").unwrap();
 2352|      1|        let display = entry.command_display();
 2353|      1|        assert!(display.contains("&&"));
 2354|      1|        assert!(display.contains("||"));
 2355|      1|    }
 2356|       |
 2357|       |    #[test]
 2358|      1|    fn test_config_path_creation() {
 2359|       |        // This test verifies the path logic works, but doesn't actually create files
 2360|       |        // in the user's home directory during testing
 2361|      1|        let temp_dir = TempDir::new().unwrap();
 2362|      1|        let _env_guard = env_lock().lock().unwrap();
 2363|      1|        let _home_guard = EnvVarGuard::set("HOME", temp_dir.path());
 2364|      1|        let _userprofile_guard = EnvVarGuard::set("USERPROFILE", temp_dir.path());
 2365|       |
 2366|      1|        let path_result = AliasManager::get_config_path();
 2367|      1|        assert!(path_result.is_ok());
 2368|       |
 2369|      1|        let path = path_result.unwrap();
 2370|      1|        assert!(path.to_string_lossy().contains(".alias-mgr"));
 2371|      1|        assert!(path.to_string_lossy().ends_with("config.json"));
 2372|      1|    }
 2373|       |
 2374|       |    #[test]
 2375|      1|    fn test_substitute_parameters_positional() {
 2376|      1|        let args = vec![
 2377|      1|            "v1.0.0".to_string(),
 2378|      1|            "main".to_string(),
 2379|      1|            "feature".to_string(),
 2380|       |        ];
 2381|       |
 2382|       |        // Test basic positional parameters
 2383|      1|        assert_eq!(
 2384|      1|            AliasManager::substitute_parameters("git tag $1", &args),
 2385|       |            "git tag v1.0.0"
 2386|       |        );
 2387|      1|        assert_eq!(
 2388|      1|            AliasManager::substitute_parameters("git checkout $2", &args),
 2389|       |            "git checkout main"
 2390|       |        );
 2391|      1|        assert_eq!(
 2392|      1|            AliasManager::substitute_parameters("git merge $2 $3", &args),
 2393|       |            "git merge main feature"
 2394|       |        );
 2395|       |
 2396|       |        // Test out of bounds (should substitute with empty string)
 2397|      1|        assert_eq!(
 2398|      1|            AliasManager::substitute_parameters("git tag $5", &args),
 2399|       |            "git tag "
 2400|       |        );
 2401|       |
 2402|       |        // Test $0 (should substitute with empty string - 1-indexed)
 2403|      1|        assert_eq!(
 2404|      1|            AliasManager::substitute_parameters("git tag $0", &args),
 2405|       |            "git tag "
 2406|       |        );
 2407|      1|    }
 2408|       |
 2409|       |    #[test]
 2410|      1|    fn test_substitute_parameters_all_args() {
 2411|      1|        let args = vec![
 2412|      1|            "file1.txt".to_string(),
 2413|      1|            "file2.txt".to_string(),
 2414|      1|            "file3.txt".to_string(),
 2415|       |        ];
 2416|       |
 2417|       |        // Test $@ (all arguments)
 2418|      1|        assert_eq!(
 2419|      1|            AliasManager::substitute_parameters("echo $@", &args),
 2420|       |            "echo file1.txt file2.txt file3.txt"
 2421|       |        );
 2422|       |
 2423|       |        // Test $* (all arguments - same as $@ in our implementation)
 2424|      1|        assert_eq!(
 2425|      1|            AliasManager::substitute_parameters("echo $*", &args),
 2426|       |            "echo file1.txt file2.txt file3.txt"
 2427|       |        );
 2428|       |
 2429|       |        // Test empty args
 2430|      1|        let empty_args: Vec<String> = vec![];
 2431|      1|        assert_eq!(
 2432|      1|            AliasManager::substitute_parameters("echo $@", &empty_args),
 2433|       |            "echo "
 2434|       |        );
 2435|      1|        assert_eq!(
 2436|      1|            AliasManager::substitute_parameters("echo $*", &empty_args),
 2437|       |            "echo "
 2438|       |        );
 2439|      1|    }
 2440|       |
 2441|       |    #[test]
 2442|      1|    fn test_substitute_parameters_escapes() {
 2443|      1|        let args = vec!["value".to_string()];
 2444|       |
 2445|       |        // Test literal dollar sign
 2446|      1|        assert_eq!(
 2447|      1|            AliasManager::substitute_parameters("echo $$", &args),
 2448|       |            "echo $"
 2449|       |        );
 2450|      1|        assert_eq!(
 2451|      1|            AliasManager::substitute_parameters("echo $$ $1", &args),
 2452|       |            "echo $ value"
 2453|       |        );
 2454|       |
 2455|       |        // Test $ at end of string
 2456|      1|        assert_eq!(
 2457|      1|            AliasManager::substitute_parameters("echo $", &args),
 2458|       |            "echo $"
 2459|       |        );
 2460|       |
 2461|       |        // Test $ followed by non-special character
 2462|      1|        assert_eq!(
 2463|      1|            AliasManager::substitute_parameters("echo $x", &args),
 2464|       |            "echo $x"
 2465|       |        );
 2466|      1|        assert_eq!(
 2467|      1|            AliasManager::substitute_parameters("echo $hello", &args),
 2468|       |            "echo $hello"
 2469|       |        );
 2470|      1|    }
 2471|       |
 2472|       |    #[test]
 2473|      1|    fn test_substitute_parameters_complex() {
 2474|      1|        let args = vec!["v1.0.0".to_string(), "origin".to_string()];
 2475|       |
 2476|       |        // Test complex real-world example
 2477|      1|        let command = "git tag $1 && git push $2 $1";
 2478|      1|        let expected = "git tag v1.0.0 && git push origin v1.0.0";
 2479|      1|        assert_eq!(
 2480|      1|            AliasManager::substitute_parameters(command, &args),
 2481|       |            expected
 2482|       |        );
 2483|       |
 2484|       |        // Test mixed variables and literals
 2485|      1|        let command = "echo 'Version: $1, Remote: $2, Cost: $$5'";
 2486|      1|        let expected = "echo 'Version: v1.0.0, Remote: origin, Cost: $5'";
 2487|      1|        assert_eq!(
 2488|      1|            AliasManager::substitute_parameters(command, &args),
 2489|       |            expected
 2490|       |        );
 2491|      1|    }
 2492|       |
 2493|       |    #[test]
 2494|      1|    fn test_substitute_parameters_edge_cases() {
 2495|      1|        let args = vec!["test".to_string()];
 2496|       |
 2497|       |        // Test multiple consecutive variables
 2498|      1|        assert_eq!(
 2499|      1|            AliasManager::substitute_parameters("$1$1$1", &args),
 2500|       |            "testtesttest"
 2501|       |        );
 2502|       |
 2503|       |        // Test variables at start and end
 2504|      1|        assert_eq!(
 2505|      1|            AliasManager::substitute_parameters("$1 middle $1", &args),
 2506|       |            "test middle test"
 2507|       |        );
 2508|       |
 2509|       |        // Test only variables
 2510|      1|        assert_eq!(AliasManager::substitute_parameters("$1", &args), "test");
 2511|      1|        assert_eq!(AliasManager::substitute_parameters("$@", &args), "test");
 2512|       |
 2513|       |        // Test no variables
 2514|      1|        assert_eq!(
 2515|      1|            AliasManager::substitute_parameters("echo hello", &args),
 2516|       |            "echo hello"
 2517|       |        );
 2518|      1|    }
 2519|       |
 2520|       |    #[test]
 2521|      1|    fn test_has_parameter_variables() {
 2522|       |        // Test positional parameters
 2523|      1|        assert!(AliasManager::has_parameter_variables("git tag $1"));
 2524|      1|        assert!(AliasManager::has_parameter_variables("git push $2 $1"));
 2525|      1|        assert!(AliasManager::has_parameter_variables("echo $9"));
 2526|       |
 2527|       |        // Test special parameters
 2528|      1|        assert!(AliasManager::has_parameter_variables("echo $@"));
 2529|      1|        assert!(AliasManager::has_parameter_variables("echo $*"));
 2530|       |
 2531|       |        // Test mixed content
 2532|      1|        assert!(AliasManager::has_parameter_variables(
 2533|      1|            "git tag $1 && git push origin $1"
 2534|       |        ));
 2535|       |
 2536|       |        // Test no variables
 2537|      1|        assert!(!AliasManager::has_parameter_variables("git status"));
 2538|      1|        assert!(!AliasManager::has_parameter_variables("echo hello world"));
 2539|       |
 2540|       |        // Test escaped dollar signs (should not count as variables)
 2541|      1|        assert!(!AliasManager::has_parameter_variables("echo $$"));
 2542|      1|        assert!(!AliasManager::has_parameter_variables("echo $$ literal"));
 2543|       |
 2544|       |        // Test dollar followed by non-special chars
 2545|      1|        assert!(!AliasManager::has_parameter_variables("echo $hello"));
 2546|      1|        assert!(!AliasManager::has_parameter_variables("echo $abc"));
 2547|       |
 2548|       |        // Test dollar at end
 2549|      1|        assert!(!AliasManager::has_parameter_variables("echo $"));
 2550|      1|    }
 2551|       |
 2552|       |    #[test]
 2553|      1|    fn test_substitute_parameters_multi_digit() {
 2554|     12|        let args = (1..=12).map(|i| format!("val{}", i)).collect::<Vec<_>>();
                          ^1      ^1      ^1                           ^1
 2555|      1|        assert_eq!(
 2556|      1|            AliasManager::substitute_parameters("echo $10", &args),
 2557|       |            "echo val10"
 2558|       |        );
 2559|      1|        assert_eq!(
 2560|      1|            AliasManager::substitute_parameters("$12-$1", &args),
 2561|       |            "val12-val1"
 2562|       |        );
 2563|      1|    }
 2564|       |
 2565|       |    #[test]
 2566|      1|    fn test_parameter_substitution_integration() {
 2567|      1|        let mut config = Config::new();
 2568|       |
 2569|       |        // Test that command with variables is stored correctly
 2570|      1|        let chain = CommandChain {
 2571|      1|            commands: vec![
 2572|      1|                ChainCommand {
 2573|      1|                    command: "git tag $1".to_string(),
 2574|      1|                    operator: None,
 2575|      1|                },
 2576|      1|                ChainCommand {
 2577|      1|                    command: "git push origin $1".to_string(),
 2578|      1|                    operator: Some(ChainOperator::And),
 2579|      1|                },
 2580|      1|            ],
 2581|      1|            parallel: false,
 2582|      1|        };
 2583|       |
 2584|      1|        config
 2585|      1|            .add_alias(
 2586|      1|                "tag-push".to_string(),
 2587|      1|                CommandType::Chain(chain),
 2588|      1|                Some("Tag and push".to_string()),
 2589|       |                false,
 2590|       |            )
 2591|      1|            .unwrap();
 2592|       |
 2593|      1|        let entry = config.get_alias("tag-push").unwrap();
 2594|      1|        let display = entry.command_display();
 2595|      1|        assert!(display.contains("git tag $1"));
 2596|      1|        assert!(display.contains("git push origin $1"));
 2597|      1|    }
 2598|       |
 2599|       |    #[test]
 2600|      1|    fn test_export_config_to_current_dir() {
 2601|      1|        let (mut manager, temp_dir) = create_test_manager();
 2602|       |
 2603|       |        // Add some aliases to export
 2604|      1|        manager
 2605|      1|            .add_alias(
 2606|      1|                "test1".to_string(),
 2607|      1|                CommandType::Simple("echo test1".to_string()),
 2608|      1|                None,
 2609|       |                false,
 2610|       |            )
 2611|      1|            .unwrap();
 2612|      1|        manager
 2613|      1|            .add_alias(
 2614|      1|                "test2".to_string(),
 2615|      1|                CommandType::Simple("echo test2".to_string()),
 2616|      1|                Some("Test 2".to_string()),
 2617|       |                false,
 2618|       |            )
 2619|      1|            .unwrap();
 2620|       |
 2621|       |        // Create a target directory within the temp directory
 2622|      1|        let target_dir = temp_dir.path().join("export_test");
 2623|      1|        fs::create_dir_all(&target_dir).unwrap();
 2624|       |
 2625|       |        // Change to the target directory (simulate current directory)
 2626|      1|        let _dir_guard = WorkingDirGuard::change_to(&target_dir).unwrap();
 2627|       |
 2628|       |        // Export config (should go to current directory)
 2629|      1|        let result = manager.export_config(None);
 2630|      1|        assert!(result.is_ok());
 2631|       |
 2632|       |        // Verify the exported file exists and has correct content
 2633|      1|        let exported_file = target_dir.join("config.json");
 2634|      1|        assert!(exported_file.exists());
 2635|       |
 2636|       |        // Load the exported config and verify it matches
 2637|      1|        let exported_content = fs::read_to_string(&exported_file).unwrap();
 2638|      1|        let exported_config: Config = serde_json::from_str(&exported_content).unwrap();
 2639|       |
 2640|      1|        assert_eq!(exported_config.aliases.len(), 2);
 2641|      1|        assert!(exported_config.get_alias("test1").is_some());
 2642|      1|        assert!(exported_config.get_alias("test2").is_some());
 2643|      1|    }
 2644|       |
 2645|       |    #[test]
 2646|      1|    fn test_export_config_to_specified_dir() {
 2647|      1|        let (mut manager, temp_dir) = create_test_manager();
 2648|       |
 2649|       |        // Add an alias to export
 2650|      1|        manager
 2651|      1|            .add_alias(
 2652|      1|                "test".to_string(),
 2653|      1|                CommandType::Simple("echo test".to_string()),
 2654|      1|                None,
 2655|       |                false,
 2656|       |            )
 2657|      1|            .unwrap();
 2658|       |
 2659|       |        // Create a target directory
 2660|      1|        let target_dir = temp_dir.path().join("specified_target");
 2661|       |
 2662|       |        // Export config to specified directory
 2663|      1|        let result = manager.export_config(Some(target_dir.to_str().unwrap()));
 2664|      1|        assert!(result.is_ok());
 2665|       |
 2666|       |        // Verify the exported file exists
 2667|      1|        let exported_file = target_dir.join("config.json");
 2668|      1|        assert!(exported_file.exists());
 2669|       |
 2670|       |        // Verify content
 2671|      1|        let exported_content = fs::read_to_string(&exported_file).unwrap();
 2672|      1|        let exported_config: Config = serde_json::from_str(&exported_content).unwrap();
 2673|      1|        assert_eq!(exported_config.aliases.len(), 1);
 2674|      1|    }
 2675|       |
 2676|       |    #[test]
 2677|      1|    fn test_export_config_creates_directory() {
 2678|      1|        let (mut manager, temp_dir) = create_test_manager();
 2679|       |
 2680|       |        // Add an alias to export
 2681|      1|        manager
 2682|      1|            .add_alias(
 2683|      1|                "test".to_string(),
 2684|      1|                CommandType::Simple("echo test".to_string()),
 2685|      1|                None,
 2686|       |                false,
 2687|       |            )
 2688|      1|            .unwrap();
 2689|       |
 2690|       |        // Specify non-existent target directory
 2691|      1|        let target_dir = temp_dir
 2692|      1|            .path()
 2693|      1|            .join("non_existent")
 2694|      1|            .join("nested")
 2695|      1|            .join("dir");
 2696|       |
 2697|       |        // Export should create the directory structure
 2698|      1|        let result = manager.export_config(Some(target_dir.to_str().unwrap()));
 2699|      1|        assert!(result.is_ok());
 2700|       |
 2701|       |        // Verify directory was created and file exists
 2702|      1|        assert!(target_dir.exists());
 2703|      1|        assert!(target_dir.is_dir());
 2704|      1|        assert!(target_dir.join("config.json").exists());
 2705|      1|    }
 2706|       |
 2707|       |    #[test]
 2708|      1|    fn test_export_config_no_source() {
 2709|      1|        let temp_dir = TempDir::new().unwrap();
 2710|      1|        let config_path = temp_dir.path().join("nonexistent_config.json");
 2711|       |
 2712|      1|        let runner: Arc<dyn CommandRunner + Send + Sync> = Arc::new(MockCommandRunner::new());
 2713|      1|        let github: Arc<dyn GitHubClient + Send + Sync> = Arc::new(MockGitHubClient::new());
 2714|      1|        let manager = AliasManager::with_dependencies(Config::new(), config_path, runner, github);
 2715|       |
 2716|      1|        let target_dir = temp_dir.path().join("target");
 2717|      1|        let result = manager.export_config(Some(target_dir.to_str().unwrap()));
 2718|       |
 2719|       |        // Should fail because source config doesn't exist
 2720|      1|        assert!(result.is_err());
 2721|      1|        assert!(result
 2722|      1|            .unwrap_err()
 2723|      1|            .contains("Source config file does not exist"));
 2724|      1|    }
 2725|       |
 2726|       |    #[test]
 2727|      1|    fn test_export_config_target_is_file() {
 2728|      1|        let (mut manager, temp_dir) = create_test_manager();
 2729|       |
 2730|       |        // Add an alias to export
 2731|      1|        manager
 2732|      1|            .add_alias(
 2733|      1|                "test".to_string(),
 2734|      1|                CommandType::Simple("echo test".to_string()),
 2735|      1|                None,
 2736|       |                false,
 2737|       |            )
 2738|      1|            .unwrap();
 2739|       |
 2740|       |        // Create a file at the target path (not a directory)
 2741|      1|        let target_file = temp_dir.path().join("existing_file.txt");
 2742|      1|        fs::write(&target_file, "existing content").unwrap();
 2743|       |
 2744|       |        // Export should fail because target exists and is not a directory
 2745|      1|        let result = manager.export_config(Some(target_file.to_str().unwrap()));
 2746|      1|        assert!(result.is_err());
 2747|      1|        assert!(result
 2748|      1|            .unwrap_err()
 2749|      1|            .contains("exists but is not a directory"));
 2750|      1|    }
 2751|       |
 2752|       |    #[test]
 2753|      1|    fn test_github_token_precedence() {
 2754|      1|        let _env_guard = env_lock().lock().unwrap();
 2755|      1|        let _gh_guard = EnvVarGuard::set("GH_TOKEN", "third");
 2756|      1|        let _git_guard = EnvVarGuard::set("GITHUB_TOKEN", "second");
 2757|      1|        let _a_guard = EnvVarGuard::set("A_GITHUB_TOKEN", "first");
 2758|       |
 2759|      1|        assert_eq!(AliasManager::github_token().as_deref(), Some("first"));
 2760|      1|    }
 2761|       |
 2762|       |    #[test]
 2763|      1|    fn test_push_config_to_github_updates_existing_file() {
 2764|      1|        let _env_guard = env_lock().lock().unwrap();
 2765|      1|        let responses = vec![
 2766|      1|            Ok(GitHubResponse::from_json(
 2767|      1|                200,
 2768|      1|                serde_json::json!({"sha": "existing-sha"}),
 2769|      1|            )),
 2770|      1|            Ok(GitHubResponse::from_status(200)),
 2771|       |        ];
 2772|      1|        let (manager, _temp_dir, _runner, github) =
 2773|      1|            create_manager_with_mocks(Vec::new(), responses);
 2774|       |
 2775|      1|        fs::write(&manager.config_path, r#"{"aliases":{}}"#).unwrap();
 2776|      1|        let _token_guard = EnvVarGuard::set("A_GITHUB_TOKEN", "test-token");
 2777|       |
 2778|      1|        manager
 2779|      1|            .push_config_to_github(Some("test message"))
 2780|      1|            .expect("push succeeds");
 2781|       |
 2782|      1|        let requests = github.requests();
 2783|      1|        assert_eq!(requests.len(), 2);
 2784|      1|        assert_eq!(requests[0].method, "GET");
 2785|      1|        let put_request = requests
 2786|      1|            .iter()
 2787|      2|            .find(|req| req.method == "PUT")
                           ^1
 2788|      1|            .expect("PUT request captured");
 2789|      1|        let body = put_request.body.as_ref().expect("body present");
 2790|      1|        assert_eq!(body["message"], "test message");
 2791|      1|        assert_eq!(body["sha"], "existing-sha");
 2792|      1|        assert!(put_request
 2793|      1|            .headers
 2794|      1|            .iter()
 2795|      2|            .any(|(k, v)| k.eq_ignore_ascii_case("authorization") && v == "Bearer test-token"));
                           ^1                                                      ^1
 2796|      1|    }
 2797|       |
 2798|       |    #[test]
 2799|      1|    fn test_push_config_to_github_creates_file_when_missing() {
 2800|      1|        let _env_guard = env_lock().lock().unwrap();
 2801|      1|        let responses = vec![
 2802|      1|            Ok(GitHubResponse::from_status(404)),
 2803|      1|            Ok(GitHubResponse::from_status(201)),
 2804|       |        ];
 2805|      1|        let (manager, _temp_dir, _runner, github) =
 2806|      1|            create_manager_with_mocks(Vec::new(), responses);
 2807|       |
 2808|      1|        fs::write(&manager.config_path, r#"{"aliases":{}}"#).unwrap();
 2809|      1|        let _token_guard = EnvVarGuard::set("A_GITHUB_TOKEN", "push-token");
 2810|       |
 2811|      1|        manager.push_config_to_github(None).expect("push succeeds");
 2812|       |
 2813|      1|        let requests = github.requests();
 2814|      1|        assert_eq!(requests.len(), 2);
 2815|      1|        let body = requests
 2816|      1|            .iter()
 2817|      2|            .find(|req| req.method == "PUT")
                           ^1
 2818|      1|            .and_then(|req| req.body.as_ref())
 2819|      1|            .expect("body present");
 2820|      1|        assert_eq!(
 2821|      1|            body["message"],
 2822|      1|            serde_json::Value::String("chore(config): update alias config".to_string())
 2823|       |        );
 2824|      1|        assert!(body.get("sha").is_none());
 2825|      1|    }
 2826|       |
 2827|       |    #[test]
 2828|      1|    fn test_push_config_to_github_propagates_failure() {
 2829|      1|        let _env_guard = env_lock().lock().unwrap();
 2830|      1|        let responses = vec![
 2831|      1|            Ok(GitHubResponse::from_status(404)),
 2832|      1|            Ok(GitHubResponse::from_status(500)),
 2833|       |        ];
 2834|      1|        let (manager, _temp_dir, _runner, _github) =
 2835|      1|            create_manager_with_mocks(Vec::new(), responses);
 2836|       |
 2837|      1|        fs::write(&manager.config_path, r#"{"aliases":{}}"#).unwrap();
 2838|      1|        let _token_guard = EnvVarGuard::set("A_GITHUB_TOKEN", "push-token");
 2839|       |
 2840|      1|        let err = manager
 2841|      1|            .push_config_to_github(None)
 2842|      1|            .expect_err("push should fail");
 2843|      1|        assert!(err.contains("GitHub API returned status 500"));
 2844|      1|    }
 2845|       |
 2846|       |    #[test]
 2847|      1|    fn test_pull_config_from_github_writes_file_and_backup() {
 2848|      1|        let _env_guard = env_lock().lock().unwrap();
 2849|      1|        let new_config = r#"{"aliases":{"remote":{"command_type":{"Simple":"echo remote"},"description":null,"created":"2025-10-20"}}}"#;
 2850|      1|        let encoded = base64::engine::general_purpose::STANDARD.encode(new_config);
 2851|      1|        let responses = vec![Ok(GitHubResponse::from_json(
 2852|      1|            200,
 2853|      1|            serde_json::json!({
 2854|      1|                "encoding": "base64",
 2855|      1|                "content": encoded
 2856|      1|            }),
 2857|      1|        ))];
 2858|      1|        let (mut manager, temp_dir, _runner, github) =
 2859|      1|            create_manager_with_mocks(Vec::new(), responses);
 2860|       |
 2861|      1|        let existing_config = r#"{"aliases":{"local":{"command_type":{"Simple":"echo local"},"description":null,"created":"2025-01-01"}}}"#;
 2862|      1|        fs::write(&manager.config_path, existing_config).unwrap();
 2863|      1|        let backup_path = manager
 2864|      1|            .config_path
 2865|      1|            .parent()
 2866|      1|            .unwrap()
 2867|      1|            .join("config.backup.json");
 2868|       |
 2869|      1|        let _token_guard = EnvVarGuard::set("GITHUB_TOKEN", "pull-token");
 2870|       |
 2871|      1|        manager.pull_config_from_github().expect("pull succeeds");
 2872|       |
 2873|      1|        assert!(backup_path.exists());
 2874|      1|        let written = fs::read_to_string(&manager.config_path).unwrap();
 2875|      1|        assert_eq!(written, new_config);
 2876|      1|        assert!(manager.config.aliases.contains_key("remote"));
 2877|       |
 2878|      1|        let requests = github.requests();
 2879|      1|        assert_eq!(requests.len(), 1);
 2880|      1|        assert_eq!(requests[0].method, "GET");
 2881|      1|        assert!(requests[0]
 2882|      1|            .headers
 2883|      1|            .iter()
 2884|      2|            .any(|(k, v)| k.eq_ignore_ascii_case("authorization") && v == "Bearer pull-token"));
                           ^1                                                      ^1
 2885|       |
 2886|      1|        let _ = fs::remove_file(temp_dir.path().join("config.backup.json"));
 2887|      1|    }
 2888|       |
 2889|       |    #[test]
 2890|      1|    fn test_pull_config_from_github_invalid_encoding_errors() {
 2891|      1|        let _env_guard = env_lock().lock().unwrap();
 2892|      1|        let responses = vec![Ok(GitHubResponse::from_json(
 2893|      1|            200,
 2894|      1|            serde_json::json!({
 2895|      1|                "encoding": "utf-8",
 2896|      1|                "content": "not-base64"
 2897|      1|            }),
 2898|      1|        ))];
 2899|      1|        let (mut manager, _temp_dir, _runner, _github) =
 2900|      1|            create_manager_with_mocks(Vec::new(), responses);
 2901|       |
 2902|      1|        let err = manager
 2903|      1|            .pull_config_from_github()
 2904|      1|            .expect_err("pull should fail");
 2905|      1|        assert!(err.contains("Unsupported encoding"));
 2906|      1|    }
 2907|       |
 2908|       |    #[test]
 2909|      1|    fn test_execute_with_real_runner_success() {
 2910|      1|        let _env_guard = env_lock().lock().unwrap();
 2911|      1|        let temp_dir = TempDir::new().unwrap();
 2912|      1|        let config_path = temp_dir.path().join("config.json");
 2913|      1|        fs::write(&config_path, r#"{"aliases":{}}"#).unwrap();
 2914|       |
 2915|      1|        let runner: Arc<dyn CommandRunner + Send + Sync> = Arc::new(SystemCommandRunner::default());
 2916|      1|        let github: Arc<dyn GitHubClient + Send + Sync> = Arc::new(MockGitHubClient::new());
 2917|      1|        let manager = AliasManager::with_dependencies(Config::new(), config_path, runner, github);
 2918|       |
 2919|       |        #[cfg(windows)]
 2920|       |        let command = "cmd /C exit 0";
 2921|       |        #[cfg(not(windows))]
 2922|      1|        let command = "true";
 2923|       |
 2924|      1|        let exit = manager
 2925|      1|            .execute_single_command_with_exit_code(command, &[])
 2926|      1|            .expect("command succeeds");
 2927|      1|        assert_eq!(exit, 0);
 2928|      1|    }
 2929|       |
 2930|       |    #[test]
 2931|      1|    fn test_execute_with_real_runner_failure() {
 2932|      1|        let _env_guard = env_lock().lock().unwrap();
 2933|      1|        let temp_dir = TempDir::new().unwrap();
 2934|      1|        let config_path = temp_dir.path().join("config.json");
 2935|      1|        fs::write(&config_path, r#"{"aliases":{}}"#).unwrap();
 2936|       |
 2937|      1|        let runner: Arc<dyn CommandRunner + Send + Sync> = Arc::new(SystemCommandRunner::default());
 2938|      1|        let github: Arc<dyn GitHubClient + Send + Sync> = Arc::new(MockGitHubClient::new());
 2939|      1|        let manager = AliasManager::with_dependencies(Config::new(), config_path, runner, github);
 2940|       |
 2941|      1|        let err = manager
 2942|      1|            .execute_single_command_with_exit_code("definitely-not-a-real-binary", &[])
 2943|      1|            .expect_err("expected failure");
 2944|      1|        assert!(err.contains("Failed to execute command"));
 2945|      1|    }
 2946|       |
 2947|       |    #[test]
 2948|      1|    fn test_ureq_github_client_get_success() {
 2949|      1|        let body = r#"{"sha":"abc"}"#;
 2950|      1|        let (url, handle) = spawn_stub_server(vec![http_response(200, "OK", body)]);
 2951|      1|        let agent = ureq::AgentBuilder::new()
 2952|      1|            .timeout(Duration::from_secs(1))
 2953|      1|            .build();
 2954|      1|        let client = UreqGitHubClient::with_agent(agent);
 2955|       |
 2956|      1|        let response = client
 2957|      1|            .get(
 2958|      1|                &format!("{}/content", url),
 2959|      1|                &[("User-Agent", "test".into())],
 2960|       |            )
 2961|      1|            .expect("request succeeds");
 2962|      1|        assert_eq!(response.status(), 200);
 2963|      1|        assert_eq!(response.json().unwrap()["sha"], "abc");
 2964|       |
 2965|      1|        handle.join().unwrap();
 2966|      1|    }
 2967|       |
 2968|       |    #[test]
 2969|      1|    fn test_ureq_github_client_get_not_found() {
 2970|      1|        let body = r#"{"message":"not found"}"#;
 2971|      1|        let (url, handle) = spawn_stub_server(vec![http_response(404, "Not Found", body)]);
 2972|      1|        let agent = ureq::AgentBuilder::new()
 2973|      1|            .timeout(Duration::from_secs(1))
 2974|      1|            .build();
 2975|      1|        let client = UreqGitHubClient::with_agent(agent);
 2976|       |
 2977|      1|        let response = client
 2978|      1|            .get(
 2979|      1|                &format!("{}/missing", url),
 2980|      1|                &[("User-Agent", "test".into())],
 2981|       |            )
 2982|      1|            .expect("request succeeds");
 2983|      1|        assert_eq!(response.status(), 404);
 2984|      1|        assert!(response.body().unwrap().contains("not found"));
 2985|       |
 2986|      1|        handle.join().unwrap();
 2987|      1|    }
 2988|       |
 2989|       |    #[test]
 2990|      1|    fn test_ureq_github_client_put_success() {
 2991|      1|        let responses = vec![http_response(201, "Created", r#"{"ok":true}"#)];
 2992|      1|        let (url, handle) = spawn_stub_server(responses);
 2993|      1|        let agent = ureq::AgentBuilder::new()
 2994|      1|            .timeout(Duration::from_secs(1))
 2995|      1|            .build();
 2996|      1|        let client = UreqGitHubClient::with_agent(agent);
 2997|       |
 2998|      1|        let response = client
 2999|      1|            .put(
 3000|      1|                &format!("{}/update", url),
 3001|      1|                [("User-Agent", "test".to_string())].as_ref(),
 3002|      1|                serde_json::json!({"message":"hi"}),
 3003|       |            )
 3004|      1|            .expect("request succeeds");
 3005|      1|        assert_eq!(response.status(), 201);
 3006|       |
 3007|      1|        handle.join().unwrap();
 3008|      1|    }
 3009|       |
 3010|       |    #[test]
 3011|      1|    fn test_system_command_runner_success() {
 3012|      1|        let runner = SystemCommandRunner::default();
 3013|       |        #[cfg(windows)]
 3014|       |        let args = vec!["/C".to_string(), "exit 0".to_string()];
 3015|       |        #[cfg(not(windows))]
 3016|      1|        let args: Vec<String> = Vec::new();
 3017|       |
 3018|       |        #[cfg(windows)]
 3019|       |        let program = "cmd";
 3020|       |        #[cfg(not(windows))]
 3021|      1|        let program = "true";
 3022|       |
 3023|      1|        let exit = runner.run(program, &args).expect("command succeeds");
 3024|      1|        assert_eq!(exit, 0);
 3025|      1|    }
 3026|       |
 3027|       |    #[test]
 3028|      1|    fn test_system_command_runner_missing_program_errors() {
 3029|      1|        let runner = SystemCommandRunner::default();
 3030|      1|        let err = runner
 3031|      1|            .run("definitely-not-a-real-binary", &[])
 3032|      1|            .expect_err("expected failure");
 3033|      1|        assert!(err.contains("Failed to execute command"));
 3034|      1|    }
 3035|       |
 3036|       |    #[test]
 3037|      1|    fn test_prepare_command_invocation_handles_quoted_args() {
 3038|      1|        let args: Vec<String> = Vec::new();
 3039|      1|        let (program, command_args) =
 3040|      1|            AliasManager::prepare_command_invocation("git commit -m \"fix login flow\"", &args)
 3041|      1|                .unwrap();
 3042|       |
 3043|      1|        assert_eq!(program, "git");
 3044|      1|        assert_eq!(
 3045|       |            command_args,
 3046|      1|            vec![
 3047|      1|                "commit".to_string(),
 3048|      1|                "-m".to_string(),
 3049|      1|                "fix login flow".to_string()
 3050|       |            ]
 3051|       |        );
 3052|      1|    }
 3053|       |
 3054|       |    #[test]
 3055|      1|    fn test_migrate_legacy_config_preserves_aliases() {
 3056|      1|        let legacy = r#"
 3057|      1|        {
 3058|      1|            "aliases": {
 3059|      1|                "gst": {
 3060|      1|                    "command": "git status",
 3061|      1|                    "description": "Quick status",
 3062|      1|                    "created": "2024-01-01"
 3063|      1|                }
 3064|      1|            }
 3065|      1|        }
 3066|      1|        "#;
 3067|       |
 3068|      1|        let config = AliasManager::migrate_legacy_config(legacy).expect("migrate legacy");
 3069|      1|        let entry = config.aliases.get("gst").expect("alias migrated");
 3070|       |
 3071|      1|        match &entry.command_type {
 3072|      1|            CommandType::Simple(cmd) => assert_eq!(cmd, "git status"),
 3073|      0|            other => panic!("unexpected command type: {:?}", other),
 3074|       |        }
 3075|      1|        assert_eq!(entry.description.as_deref(), Some("Quick status"));
 3076|      1|        assert_eq!(entry.created, "2024-01-01");
 3077|      1|    }
 3078|       |
 3079|       |    #[test]
 3080|      1|    fn test_load_config_migrates_legacy_file() {
 3081|      1|        let temp_dir = TempDir::new().unwrap();
 3082|      1|        let legacy_path = temp_dir.path().join("legacy.json");
 3083|      1|        let legacy = r#"
 3084|      1|        {
 3085|      1|            "aliases": {
 3086|      1|                "build": {
 3087|      1|                    "command": "npm run build",
 3088|      1|                    "description": null,
 3089|      1|                    "created": "2023-12-12"
 3090|      1|                }
 3091|      1|            }
 3092|      1|        }
 3093|      1|        "#;
 3094|      1|        fs::write(&legacy_path, legacy).unwrap();
 3095|       |
 3096|      1|        let config = AliasManager::load_config(&legacy_path).expect("load config");
 3097|      1|        let entry = config.aliases.get("build").expect("build alias present");
 3098|      1|        match &entry.command_type {
 3099|      1|            CommandType::Simple(cmd) => assert_eq!(cmd, "npm run build"),
 3100|      0|            other => panic!("unexpected command type: {:?}", other),
 3101|       |        }
 3102|      1|        assert_eq!(entry.description, None);
 3103|      1|    }
 3104|       |
 3105|       |    #[test]
 3106|      1|    fn test_confirm_overwrite_yes() {
 3107|      1|        let mut reader = Cursor::new(b"y\n".to_vec());
 3108|      1|        let mut output = Vec::new();
 3109|      1|        let result = AliasManager::confirm_overwrite_with_reader(&mut reader, &mut output).unwrap();
 3110|      1|        assert!(result);
 3111|      1|        let prompt = String::from_utf8(output).unwrap();
 3112|      1|        assert!(prompt.contains("Overwrite?"));
 3113|      1|    }
 3114|       |
 3115|       |    #[test]
 3116|      1|    fn test_confirm_overwrite_no_default() {
 3117|      1|        let mut reader = Cursor::new(b"\n".to_vec());
 3118|      1|        let mut output = Vec::new();
 3119|      1|        let result = AliasManager::confirm_overwrite_with_reader(&mut reader, &mut output).unwrap();
 3120|      1|        assert!(!result);
 3121|      1|    }
 3122|       |
 3123|       |    struct FailingWriter;
 3124|       |
 3125|       |    impl Write for FailingWriter {
 3126|      1|        fn write(&mut self, _buf: &[u8]) -> io::Result<usize> {
 3127|      1|            Err(io::Error::new(io::ErrorKind::Other, "cannot write"))
 3128|      1|        }
 3129|       |
 3130|      0|        fn flush(&mut self) -> io::Result<()> {
 3131|      0|            Ok(())
 3132|      0|        }
 3133|       |    }
 3134|       |
 3135|       |    #[test]
 3136|      1|    fn test_confirm_overwrite_write_error() {
 3137|      1|        let mut reader = Cursor::new(b"y\n".to_vec());
 3138|      1|        let mut writer = FailingWriter;
 3139|      1|        let err = AliasManager::confirm_overwrite_with_reader(&mut reader, &mut writer)
 3140|      1|            .expect_err("expected write failure");
 3141|      1|        assert!(err.contains("Failed to write prompt"));
 3142|      1|    }
 3143|       |
 3144|       |    #[test]
 3145|      1|    fn test_execute_alias_simple_runs_command() {
 3146|      1|        let (mut manager, _temp_dir, runner, _github) =
 3147|      1|            create_manager_with_mocks(Vec::new(), Vec::new());
 3148|      1|        runner.push_response(Ok(0));
 3149|       |
 3150|      1|        manager
 3151|      1|            .add_alias(
 3152|      1|                "hello".to_string(),
 3153|      1|                CommandType::Simple("echo hello".to_string()),
 3154|      1|                None,
 3155|       |                false,
 3156|       |            )
 3157|      1|            .unwrap();
 3158|       |
 3159|      1|        manager.execute_alias("hello", &[]).unwrap();
 3160|       |
 3161|      1|        let calls = runner.calls();
 3162|      1|        assert_eq!(calls.len(), 1);
 3163|      1|        assert_eq!(calls[0].0, "echo");
 3164|      1|        assert_eq!(calls[0].1, vec!["hello"]);
 3165|      1|    }
 3166|       |
 3167|       |    #[test]
 3168|      1|    fn test_execute_sequential_chain_respects_conditions() {
 3169|      1|        let (manager, _temp_dir, runner, _github) =
 3170|      1|            create_manager_with_mocks(vec![Ok(0), Ok(1), Ok(0)], Vec::new());
 3171|       |
 3172|      1|        let chain = CommandChain {
 3173|      1|            commands: vec![
 3174|      1|                ChainCommand {
 3175|      1|                    command: "echo first".to_string(),
 3176|      1|                    operator: None,
 3177|      1|                },
 3178|      1|                ChainCommand {
 3179|      1|                    command: "echo second".to_string(),
 3180|      1|                    operator: Some(ChainOperator::And),
 3181|      1|                },
 3182|      1|                ChainCommand {
 3183|      1|                    command: "echo third".to_string(),
 3184|      1|                    operator: Some(ChainOperator::Or),
 3185|      1|                },
 3186|      1|            ],
 3187|      1|            parallel: false,
 3188|      1|        };
 3189|       |
 3190|      1|        manager
 3191|      1|            .execute_sequential_chain(&chain, &[])
 3192|      1|            .expect("sequential chain succeeds");
 3193|       |
 3194|      1|        let calls = runner.calls();
 3195|      1|        assert_eq!(calls.len(), 3);
 3196|      1|        assert_eq!(calls[0].0, "echo");
 3197|      1|        assert_eq!(calls[1].0, "echo");
 3198|      1|        assert_eq!(calls[2].0, "echo");
 3199|      1|    }
 3200|       |
 3201|       |    #[test]
 3202|      1|    fn test_execute_parallel_chain_reports_failures() {
 3203|      1|        let (manager, _temp_dir, runner, _github) =
 3204|      1|            create_manager_with_mocks(vec![Ok(0), Err("boom".to_string()), Ok(0)], Vec::new());
 3205|       |
 3206|      1|        let chain = CommandChain {
 3207|      1|            commands: vec![
 3208|      1|                ChainCommand {
 3209|      1|                    command: "echo alpha".to_string(),
 3210|      1|                    operator: None,
 3211|      1|                },
 3212|      1|                ChainCommand {
 3213|      1|                    command: "echo beta".to_string(),
 3214|      1|                    operator: None,
 3215|      1|                },
 3216|      1|                ChainCommand {
 3217|      1|                    command: "echo gamma".to_string(),
 3218|      1|                    operator: None,
 3219|      1|                },
 3220|      1|            ],
 3221|      1|            parallel: true,
 3222|      1|        };
 3223|       |
 3224|      1|        let err = manager
 3225|      1|            .execute_parallel_chain(&chain, &[])
 3226|      1|            .expect_err("parallel chain should fail");
 3227|      1|        assert!(err.contains("parallel commands failed"));
 3228|       |
 3229|      1|        let calls = runner.calls();
 3230|      1|        assert_eq!(calls.len(), 3);
 3231|      1|    }
 3232|       |}